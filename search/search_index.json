{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LTF Documentation","text":"<p>This folder contains the primary user-facing documentation for LTF: CLI usage, project setup, logging, tags, scenarios, hooks, and more.</p>"},{"location":"#core-docs","title":"Core docs","text":"<ul> <li> <p>Command-Line Interface (CLI)   How to use the <code>ltf</code> executable (<code>init</code>, <code>test</code>, <code>target</code>, <code>logs</code>, <code>eval</code>, etc.).</p> </li> <li> <p>Project setup   Single-target vs multi-target layout, initialization, and how test discovery works.</p> </li> <li> <p>Logging   Log files, log levels, and how to use <code>ltf logs info</code>.</p> </li> <li> <p>Tag system   Add tags to tests and filter runs with <code>--tags/-t</code>.</p> </li> <li> <p>Test description   Add optional <code>description</code> text to tests (single-line or multiline).</p> </li> <li> <p>Test teardown with <code>ltf.defer</code>   Guaranteed cleanup, LIFO order, and conditional teardown behavior.</p> </li> <li> <p>Test variables   Register variables, override from CLI, validation rules, and examples.</p> </li> <li> <p>Test secrets   Register secrets, provide values via <code>.secrets</code>, multiline values, and validation.</p> </li> <li> <p>Test overriding behavior   How duplicate test names override earlier definitions (especially useful for multi-target).</p> </li> <li> <p>Test scenarios   Describe a run in JSON (vars/tags/log settings/order) and how include/append/remove works.</p> </li> <li> <p>Hooks   Register lifecycle hooks and understand the hook context types.</p> </li> </ul>"},{"location":"#internal-libraries-api-reference","title":"Internal libraries (API reference)","text":"<p>The API docs for built-in Lua libraries live under:</p> <ul> <li>LTF_LIBS (core library API docs)   Overview and per-module documentation for <code>ltf.*</code> modules (HTTP, SSH, serial, webdriver, JSON, etc.).</li> </ul>"},{"location":"CLI/","title":"LTF Command-Line Interface (CLI)","text":"<p>The <code>ltf</code> executable is the primary tool for creating, managing, and running your test projects. This guide details all available commands and their options.</p>"},{"location":"CLI/#main-commands","title":"Main Commands","text":"<p>The <code>ltf</code> executable uses a command/sub-command structure.</p> <p>Usage:</p> <pre><code>ltf &lt;command&gt; [sub-command] [arguments...] [options...]\n</code></pre> Command Description <code>init</code> Initialize a new LTF project. <code>test</code> Run tests for a project. <code>target</code> Manage targets for a multi-target project. <code>logs</code> Parse and display information from LTF log files. <code>eval</code> Run Lua scripts with support for LTF libraries. <code>version</code> <code>--version</code> <code>help</code> <code>--help</code>"},{"location":"CLI/#ltf-init","title":"<code>ltf init</code>","text":"<p>Creates a new LTF project directory with the necessary files and structure.</p> <p>Usage:</p> <pre><code>ltf init &lt;project-name&gt; [options...]\n</code></pre>"},{"location":"CLI/#arguments","title":"Arguments","text":"<ul> <li><code>project-name</code> (required): The name of the new project. A directory with this name will be created.</li> </ul>"},{"location":"CLI/#options","title":"Options","text":"Option Alias Description <code>--multitarget</code> <code>-m</code> Initializes the project with a multi-target structure. <code>--internal-log</code> <code>-i</code> Dumps an internal LTF log file for advanced debugging. <code>--help</code> <code>-h</code> Displays the help message for the <code>init</code> command."},{"location":"CLI/#examples","title":"Examples","text":"<pre><code># Create a standard single-target project\nltf init my_api_tests\n\n# Create a project designed for multiple hardware targets\nltf init my_embedded_project --multitarget\n</code></pre>"},{"location":"CLI/#ltf-test","title":"<code>ltf test</code>","text":"<p>Executes the tests within the current project.</p> <p>Usage:</p> <ul> <li>For Single-Target projects</li> </ul> <pre><code>ltf test [options...]\n</code></pre> <ul> <li>For Multi-Target projects</li> </ul> <pre><code>ltf test &lt;target_name&gt; [options...]\n</code></pre>"},{"location":"CLI/#arguments_1","title":"Arguments","text":"<ul> <li><code>target_name</code> (optional): The name of the target to run tests against. This is required for multi-target projects.</li> </ul>"},{"location":"CLI/#options_1","title":"Options","text":"Option Alias Description <code>--log-level &lt;level&gt;</code> <code>-l</code> Sets the minimum log level to display in the TUI. Valid levels are <code>critical</code>, <code>error</code>, <code>warning</code>, <code>info</code>, <code>debug</code>, <code>trace</code>. See Logging. <code>--no-logs</code> <code>-n</code> Disables the creation of log files for this test run. <code>--skip-hooks</code> Disables LTF hooks for this test run. <code>--ltf-lib-path &lt;path&gt;</code> <code>-p</code> Provide custom path to LTF Lua libraries location. <code>--tags &lt;tags&gt;</code> <code>-t</code> Runs only tests that have at least one of the specified comma-separated tags. See Tag System. <code>--vars &lt;vars&gt;</code> <code>-v</code> Set one or more test variables as a comma-separated list of <code>name:value</code> pairs. See Test Variables. <code>--scenario &lt;file&gt;</code> <code>-s</code> Run using a scenario JSON file (tags/vars/log settings/ordering). CLI flags still override scenario values. See Test Scenarios. <code>--internal-log</code> <code>-i</code> Dumps an internal LTF log file for advanced debugging. <code>--headless</code> <code>-e</code> Runs LTF in \"headless\" mode (no TUI). Performs faster but without fancy TUI. <code>--help</code> <code>-h</code> Displays the help message for the <code>test</code> command."},{"location":"CLI/#examples_1","title":"Examples","text":"<ul> <li>Run all tests in a single-target project</li> </ul> <pre><code>ltf test\n</code></pre> <ul> <li>Run only smoke tests</li> </ul> <pre><code>ltf test --tags smoke\n</code></pre> <ul> <li>Run tests for a specific target in a multi-target project with a verbose log level</li> </ul> <pre><code>ltf test my_board_v2 -l debug\n</code></pre>"},{"location":"CLI/#test-variables-vars-v","title":"Test variables (<code>--vars</code> / <code>-v</code>)","text":"<p>Variables let you parameterize your test runs and override values from the command line.</p> <p>Format: comma-separated <code>name:value</code> pairs</p> <pre><code>ltf test --vars serial_port:/dev/ttyUSB0,env:staging,log_level:debug\n</code></pre> <p>Shorthand:</p> <pre><code>ltf test -v serial_port:/dev/ttyUSB0,env:staging\n</code></pre> <p>Notes:</p> <ul> <li>Values are treated as strings on the CLI side.</li> <li>Variable validation happens before any tests run (required vars must be provided; enums must match allowed values, etc.).</li> </ul> <p>See: Test Variables</p>"},{"location":"CLI/#test-scenarios-scenario-s","title":"Test scenarios (<code>--scenario</code> / <code>-s</code>)","text":"<p>Scenarios let you describe a test run in a JSON file: variables, tags, log settings, and (optionally) a preferred test execution order.</p> <p>Run a scenario:</p> <pre><code>ltf test -s scenarios/scenario.json\n</code></pre>"},{"location":"CLI/#cli-overrides-scenario-values","title":"CLI overrides scenario values","text":"<p>Anything under <code>cmd</code> in the scenario can still be overridden with CLI flags. CLI always wins.</p> <pre><code>ltf test -s scenarios/scenario.json -v var1:new_value\n</code></pre> <p>See: Test Scenarios</p>"},{"location":"CLI/#ltf-target","title":"<code>ltf target</code>","text":"<p>Manages the targets in a multi-target project. This command requires a sub-command.</p>"},{"location":"CLI/#ltf-target-add","title":"<code>ltf target add</code>","text":"<p>Adds a new target to the project and creates its corresponding test directory.</p> <p>Usage:</p> <pre><code>ltf target add &lt;target_name&gt;\n</code></pre> <ul> <li>Arguments: <code>target_name</code> (required) - The name of the new target to add.</li> </ul>"},{"location":"CLI/#ltf-target-remove","title":"<code>ltf target remove</code>","text":"<p>Removes a target from the project's configuration.</p> <p>Usage:</p> <pre><code>ltf target remove &lt;target_name&gt;\n</code></pre> <ul> <li>Arguments: <code>target_name</code> (required) - The name of the target to remove.</li> </ul> <p>Note: The <code>remove</code> command does not delete the target's test directory, allowing you to manage the files manually.</p>"},{"location":"CLI/#ltf-logs","title":"<code>ltf logs</code>","text":"<p>Provides utilities for interacting with LTF log files. This command requires a sub-command.</p>"},{"location":"CLI/#ltf-logs-info","title":"<code>ltf logs info</code>","text":"<p>Parses a raw JSON log file and displays a summary of the test run.</p> <p>Usage:</p> <pre><code>ltf logs info &lt;path_to_log | latest&gt;\n</code></pre>"},{"location":"CLI/#arguments_2","title":"Arguments","text":"<ul> <li><code>path_to_log | latest</code> (required): Either the literal string <code>latest</code> to parse the most recent log, or the file path to a specific <code>test_run_[...]_raw.json</code> file.</li> </ul>"},{"location":"CLI/#example","title":"Example","text":"<pre><code># Get a summary of the last test run\nltf logs info latest\n</code></pre>"},{"location":"CLI/#ltf-eval","title":"<code>ltf eval</code>","text":"<p>Runs specified lua file with access to LTF libraries. Useful for scripts.</p> <p>Usage:</p> <pre><code>ltf eval &lt;file.lua&gt; -- [args...]\n</code></pre>"},{"location":"CLI/#arguments_3","title":"Arguments","text":"<ul> <li><code>file.lua</code>: Lua script to run</li> <li><code>args</code>: any amount of arguments passed to the Lua in the <code>arg</code> table</li> </ul>"},{"location":"CLI/#example_1","title":"Example","text":"<pre><code>--- script.lua\nlocal ltf = require(\"ltf\")\n\nprint(\"Hello, \" .. arg[1])\nprint(arg[2])\n</code></pre> <pre><code>ltf eval script.lua -- LTF test\n</code></pre> <p>Output:</p> <pre><code>Hello, LTF\ntest\n</code></pre> <p>Note: In eval scripts, only the following functions from the LTF Core Library can be used: sleep, millis. Using any others may lead to undefined behavior. </p>"},{"location":"LSP_INTEGRATION/","title":"LSP Integration (LuaLS)","text":"<p>LTF ships with a pre-configured <code>.luarc.json</code> in every newly created project. This file is used by Lua Language Server (LuaLS) to provide a smooth editing experience:</p> <ul> <li>Autocomplete for LTF APIs (<code>ltf.test</code>, <code>ltf.log_*</code>, built-in modules, etc.)</li> <li>Type hints (from EmmyLua annotations in LTF libraries)</li> <li>Go-to-definition / find references across <code>tests/</code>, <code>lib/</code>, and <code>hooks/</code></li> <li>Better diagnostics (fewer false positives, correct globals)</li> </ul> <p>This is editor-agnostic: any editor using LuaLS will pick it up.</p>"},{"location":"LSP_INTEGRATION/#what-luarcjson-configures","title":"What <code>.luarc.json</code> configures","text":"<p>The generated <code>.luarc.json</code> typically does a few important things:</p> <ol> <li>Sets runtime to Lua 5.4 (matching LTF\u2019s embedded Lua)</li> <li>Tells LuaLS where to find library code</li> <li>Your project code: <code>tests/</code>, <code>lib/</code>, <code>hooks/</code></li> <li>LTF built-in libs: the LTF Lua library directory (usually under <code>~/.ltf/lib</code>)</li> <li>Configures diagnostics</li> <li>Allows common globals used in LTF tests (like <code>args</code> in <code>ltf eval</code>)</li> <li>Reduces \u201cundefined global\u201d noise where appropriate</li> <li>Enables/uses type annotations</li> <li>LTF libraries include EmmyLua types (<code>---@class</code>, <code>---@field</code>, etc.)</li> <li>LuaLS uses these to show rich hints</li> </ol>"},{"location":"LSP_INTEGRATION/#using-a-custom-ltf-library-location","title":"Using a custom LTF library location","text":"<p>By default, LTF installs its Lua libraries into:</p> <ul> <li><code>~/.ltf/lib</code> (default)</li> <li>or the path you built LTF with using Meson option <code>-Dltf_dir_path=...</code></li> </ul> <p>If you run tests with a custom library path:</p> <pre><code>ltf test --ltf-lib-path /some/other/path\n````\n\n\u2026and LuaLS cannot resolve `require(\"ltf\")` or `ltf.*` modules, update your `.luarc.json` so that LuaLS also searches that path.\n\n## How to verify everything is working\n\nOpen `tests/example_test.lua` and type:\n\n```lua\nlocal ltf = require(\"ltf\")\nltf.\n</code></pre> <p>If you see:</p> <ul> <li>autocomplete suggestions</li> <li>function docs/type hints</li> </ul> <p>\u2026then LuaLS is correctly configured.</p>"},{"location":"PROJECT_SETUP/","title":"LTF Project Setup","text":"<p>The Test Automation Framework (LTF) is designed to be flexible, offering two primary project structures to suit your testing needs: Single-Target and Multi-Target.</p>"},{"location":"PROJECT_SETUP/#single-target-project-default","title":"Single-Target Project (Default)","text":"<p>This is the standard project structure, perfect for testing a single application, service, or piece of hardware.</p>"},{"location":"PROJECT_SETUP/#structure","title":"\ud83d\udcc1 Structure","text":"<p>The <code>ltf init</code> command creates a clean and logical directory layout:</p> <pre><code>your_project/\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 your_custom_library.lua\n\u2502   \u2514\u2500\u2500 variables.lua\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 example_test_1.lua\n\u2502   \u2514\u2500\u2500 example_test_2.lua\n\u2514\u2500\u2500 .ltf.json\n</code></pre> <ul> <li><code>tests/</code>: This is the heart of your project, where all your test files (<code>*_test.lua</code>) reside.</li> <li><code>lib/</code>: This directory is designed for reusable code, helper functions, and abstractions that can be shared across multiple tests. Keeping this logic separate helps maintain clean and readable test files.</li> <li><code>.ltf.json</code>: An auto-generated file used internally by LTF to manage your project's configuration.     &gt; Warning: Do not edit <code>.ltf.json</code> manually. Use <code>ltf</code> commands to manage project settings.</li> </ul>"},{"location":"PROJECT_SETUP/#initialization","title":"\ud83d\ude80 Initialization","text":"<p>To create a new single-target project, run the <code>init</code> command:</p> <pre><code>ltf init your_project_name\n</code></pre> <p>This will create the <code>your_project_name</code> directory and populate it with the <code>lib/</code>, <code>tests/</code>, and <code>.ltf.json</code> files.</p> <p>Note: Single-Target project may be converted to Multi-Target by Adding a Target</p>"},{"location":"PROJECT_SETUP/#multi-target-project","title":"Multi-Target Project","text":"<p>If your testing involves multiple distinct environments or devices (e.g., several different embedded Linux boards, various API endpoints), the multi-target structure provides the necessary organization.</p>"},{"location":"PROJECT_SETUP/#structure_1","title":"\ud83d\udcc1 Structure","text":"<p>A multi-target project extends the standard structure by organizing tests into target-specific subdirectories.</p> <pre><code>your_project/\n\u251c\u2500\u2500 lib/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 common/\n\u2502   \u2502   \u251c\u2500\u2500 common_test_1.lua\n\u2502   \u2502   \u2514\u2500\u2500 common_test_2.lua\n\u2502   \u251c\u2500\u2500 example_target_1/\n\u2502   \u2502   \u2514\u2500\u2500 target_1_tests.lua\n\u2502   \u2514\u2500\u2500 example_target_2/\n\u2502       \u2514\u2500\u2500 target_2_tests.lua\n\u2514\u2500\u2500 .ltf.json\n</code></pre> <ul> <li><code>tests/common/</code>: This special directory holds tests that are generic and can be run against any of your defined targets. LTF will always look for tests here.</li> <li><code>tests/&lt;target_name&gt;/</code>: Each target you add to the project gets its own directory for tests that are specific to that target.</li> </ul>"},{"location":"PROJECT_SETUP/#initialization_1","title":"\ud83d\ude80 Initialization","text":"<p>Create a multi-target project using the <code>--multitarget</code> flag:</p> <pre><code>ltf init your_project_name --multitarget\n</code></pre> <p>This will create the base structure, including the essential <code>tests/common/</code> directory.</p> <p>Note: Multi-Target project may be converted to Single-Target by Removing a Target when you only have 1 target left</p>"},{"location":"PROJECT_SETUP/#managing-targets","title":"Managing Targets","text":"<p>You can easily add and remove targets from your project.</p>"},{"location":"PROJECT_SETUP/#adding-a-target","title":"Adding a Target","text":"<p>Use the <code>ltf target add</code> command to register a new target and create its test directory:</p> <pre><code>ltf target add example_target_1\n</code></pre>"},{"location":"PROJECT_SETUP/#removing-a-target","title":"Removing a Target","text":"<p>Use the <code>ltf target remove</code> command to unregister a target:</p> <pre><code>ltf target remove example_target_1\n</code></pre> <p>Note: This command only removes the target from LTF's internal tracking. It will not delete the <code>tests/example_target_1/</code> directory or its contents, giving you full control over your files.</p>"},{"location":"PROJECT_SETUP/#a-note-on-file-naming","title":"A Note on File Naming","text":"<p>LTF does not enforce any specific naming conventions for your test or library files. You are free to name them as you see fit. LTF automatically scans the <code>tests/</code> directory (and its subdirectories) to discover all <code>ltf.test()</code> definitions.</p>"},{"location":"PROJECT_SETUP/#getting-started-your-first-test","title":"Getting Started: Your First Test","text":"<p>This quickstart guide will walk you through creating and running a simple test.</p>"},{"location":"PROJECT_SETUP/#1-initialize-a-new-project","title":"1. Initialize a New Project","text":"<p>First, create a new LTF project using the <code>init</code> command and navigate into the newly created directory.</p> <pre><code>ltf init my_first_ltf_project\ncd my_first_ltf_project\n</code></pre>"},{"location":"PROJECT_SETUP/#2-write-your-test","title":"2. Write Your Test","text":"<p>Next, create a new file inside the <code>tests/</code> directory (e.g., <code>tests/hello_world_test.lua</code>) and add the following code:</p> <pre><code>-- Require the LTF core library\nlocal ltf = require(\"ltf\")\n\n-- Define a new test case\nltf.test({\n    name = \"My Very First Test\",\n    body = function()\n        ltf.log_info(\"The test is starting...\")\n        ltf.sleep(1000) -- Pause execution for 1000 milliseconds\n\n        -- ltf.print is an alias for ltf.log_info\n        ltf.print(\"Hello from LTF!\")\n\n        ltf.sleep(1000)\n        ltf.log_info(\"The test is finishing.\")\n    end,\n})\n</code></pre> <p>This is the primary function for registering a new test case. *   The <code>name</code> parameter is a <code>string</code> describing the test's purpose. *   The <code>body</code> parameter is a <code>function</code> containing the actual test logic.</p>"},{"location":"PROJECT_SETUP/#3-run-the-test","title":"3. Run the Test","text":"<p>Save the file and run your test from the project's root directory using the <code>ltf test</code> command:</p> <pre><code>ltf test\n</code></pre> <p>You will see the LTF Terminal UI launch, execute your test, and print the log messages in real-time. The test will wait for 1 second, print \"Hello from LTF!\", wait another second, and then complete.</p> <p>Congratulations! You've just written and successfully run your first LTF test.</p>"},{"location":"HOOKS/HOOKS/","title":"Hooks","text":"<p>Hooks let you run custom Lua code at specific points during a test run (before/after each test, and at the beginning/end of the run). This is useful for setup/cleanup, diagnostics, custom reporting, or collecting extra artifacts.</p> <p>Note: In hooks, only the following functions from the LTF Core Library can be used: sleep, millis, print, log. Using any others may lead to undefined behavior. </p>"},{"location":"HOOKS/HOOKS/#registering-hooks","title":"Registering hooks","text":"<p>Hooks are available under <code>ltf.hooks</code>. You can register hooks anywhere at Lua top level, but a common convention is to keep them in a dedicated folder <code>hooks/</code>.</p> <pre><code>local ltf = require(\"ltf\")\nlocal hooks = ltf.hooks\n\n-- Runs once at the start of the whole test run\nhooks.test_run_started(function(context)\n  -- ...\nend)\n\n-- Runs before each test starts\nhooks.test_started(function(context)\n  -- ...\nend)\n\n-- Runs after each test finishes\nhooks.test_finished(function(context)\n  -- ...\nend)\n\n-- Runs once after all tests have finished\nhooks.test_run_finished(function(context)\n  -- ...\nend)\n</code></pre>"},{"location":"HOOKS/HOOKS/#multiple-hooks-per-event","title":"Multiple hooks per event","text":"<p>You can register as many hooks as you want for the same event (<code>test_started</code>, <code>test_finished</code>, etc.). They execute in the order they were registered.</p>"},{"location":"HOOKS/HOOKS/#hook-context","title":"Hook context","text":"<p>Each hook receives a single argument: <code>context</code>, which has type <code>context_t</code>.</p> <ul> <li><code>context.test_run</code> contains information about the overall run (project, target, tags, timestamps, OS, etc.)</li> <li><code>context.test</code> contains information about the current test (name, file, vars, secrets, output, status, etc.)</li> <li><code>context.logs</code> contains information about the paths of log files and directories</li> </ul> <pre><code>--- @class context_t\n--- @field test_run test_run_context_t\n--- @field test test_context_t\n--- @field logs context_logs_t\n</code></pre>"},{"location":"HOOKS/HOOKS/#context-types-lua-annotations","title":"Context types (Lua annotations)","text":"<pre><code>--- @class test_run_context_t\n--- @field project_name string\n--- @field ltf_version string\n--- @field os string\n--- @field os_version string\n--- @field target string? nil if project is single-target\n--- @field started string\n--- @field finished string? nil if the test run hasn't finished yet\n--- @field tags [string]\n--- @field vars table&lt;ltf_var_name, ltf_var_value&gt;\n--- @field secrets table&lt;secret_name, secret_value&gt;\n\n--- @class test_output_t\n--- @field file string\n--- @field line integer\n--- @field date_time string\n--- @field level \"CRITICAL\"|\"ERROR\"|\"WARNING\"|\"INFO\"|\"DEBUG\"|\"TRACE\"\n--- @field msg string\n\n--- @class test_keyword_t\n--- @field name string\n--- @field started string\n--- @field finished string\n--- @field file string\n--- @field line integer\n\n--- @class test_context_t\n--- @field name string\n--- @field description string\n--- @field started string\n--- @field finished string? nil on `test_started`\n--- @field teardown_start string? nil on `test_started`\n--- @field teardown_end string? nil on `test_started`\n--- @field status \"passed\"|\"failed\"|nil nil on `test_started`\n--- @field tags [string]\n--- @field outputs [test_output_t] populated only on `test_finished`\n--- @field failure_reasons [test_output_t] populated only on `test_finished`\n--- @field teardown_output [test_output_t] populated only on `test_finished`\n--- @field teardown_errors [test_output_t] populated only on `test_finished`\n--- @field keywords [test_keyword_t] populated only on `test_finished`\n\n--- @class context_logs_t\n--- @field dir string log directory path\n--- @field raw_log string raw log file path\n--- @field output_log string output log file path\n</code></pre> <p><code>context.test</code> is always a last started test, i.e. it is updated every <code>test_started</code> hook and is nil on <code>test_run_started</code></p> <p><code>context.test.keywords</code> is essentially structured \u201ccall stack\u201d / step information for the test: nested keywords with start/finish times and source locations. This is useful for building custom summaries or debugging timelines.</p>"},{"location":"HOOKS/HOOKS/#example","title":"Example","text":"<p>See project example</p>"},{"location":"LTF_LIBS/","title":"LTF Core Libraries","text":"<p>Welcome to the documentation for the LTF core libraries. These libraries are the building blocks for writing tests: core test registration + logging, plus modules for processes, HTTP, SSH, serial devices, JSON, browser automation, and more.</p> <p>All core modules are accessed through the main <code>ltf</code> entry point:</p> <pre><code>local ltf = require(\"ltf\")\n</code></pre>"},{"location":"LTF_LIBS/#available-modules","title":"Available modules","text":"<p>Each module provides a focused set of functionality. Click a module to open its API docs.</p> <ul> <li> <p><code>ltf</code> (Core Library) Purpose: The main test authoring API: define tests, log output, defer cleanup, and access variables/secrets and run context.   Key functions: <code>ltf.test()</code>, <code>ltf.log_info()</code>, <code>ltf.log_error()</code>, <code>ltf.defer()</code>, <code>ltf.register_vars()</code>, <code>ltf.register_secrets()</code></p> </li> <li> <p><code>ltf.hooks</code> Purpose: Register callbacks around the test lifecycle (run started/finished, test started/finished).   Key functions: <code>hooks.test_run_started()</code>, <code>hooks.test_started()</code>, <code>hooks.test_finished()</code>, <code>hooks.test_run_finished()</code></p> </li> <li> <p><code>ltf.proc</code> Purpose: Run and interact with external system processes. Supports synchronous execution (<code>run</code>) and interactive spawning (<code>spawn</code>).   Key functions: <code>proc.run()</code>, <code>proc.spawn()</code>, <code>handle:read()</code>, <code>handle:write()</code>, <code>handle:wait()</code>, <code>handle:kill()</code></p> </li> <li> <p><code>ltf.http</code> Purpose: Low-level HTTP client based on libcurl. Create a handle, configure options, perform the request, then cleanup.   Key functions: <code>http.new()</code>, <code>handle:setopt()</code>, <code>handle:perform()</code>, <code>handle:cleanup()</code></p> </li> <li> <p><code>ltf.ssh</code> Purpose: SSH connectivity for tests: remote command execution, interactive shell channels (PTY), and SFTP file transfer.   Key functions: <code>ssh.new_session()</code>, <code>session:connect()</code>, <code>session:new_exec_channel()</code>, <code>exec_chan:exec()</code>, <code>session:new_sftp_channel()</code></p> </li> <li> <p><code>ltf.serial</code> Purpose: Communicate with serial devices (<code>COM*</code>, <code>/dev/tty*</code>). Includes device discovery, port configuration, and read/write helpers like <code>read_until</code>.   Key functions: <code>serial.list_devices()</code>, <code>serial.get_port()</code>, <code>port:open()</code>, <code>port:read()</code>, <code>port:write()</code>, <code>port:read_until()</code></p> </li> <li> <p><code>ltf.webdriver</code> Purpose: Browser automation using the W3C WebDriver protocol. Spawn a driver, create a session, interact with pages/elements, then close.   Key functions: <code>webdriver.spawn_webdriver()</code>, <code>webdriver.new_session()</code>, <code>session:open_url()</code>, <code>session:find_element()</code>, <code>session:click()</code></p> </li> <li> <p><code>ltf.json</code> Purpose: JSON serialization/deserialization utilities for Lua tables (with formatting options).   Key functions: <code>json.serialize()</code>, <code>json.deserialize()</code></p> </li> <li> <p><code>ltf.util</code> Purpose: Small general-purpose helpers. Currently includes file inspection (<code>file_info</code>).   Key functions: <code>util.file_info()</code></p> </li> </ul>"},{"location":"LTF_LIBS/ltf.hooks/","title":"Hooks (<code>ltf.hooks</code>)","text":"<p><code>ltf.hooks</code> lets you run your own Lua callbacks at key points during a test run. Hooks are useful for:</p> <ul> <li>Setting up / tearing down external resources for the whole run</li> <li>Per-test setup/cleanup</li> <li>Collecting extra logs or artifacts</li> <li>Inspecting the run/test context (tags, status, output, keywords, etc.)</li> </ul>"},{"location":"LTF_LIBS/ltf.hooks/#getting-started","title":"Getting started","text":"<p><code>hooks</code> is exposed as a submodule of <code>ltf</code>:</p> <pre><code>local ltf = require(\"ltf\")\nlocal hooks = ltf.hooks\n</code></pre> <p>Hooks can be registered anywhere at Lua top level, but it\u2019s a good idea to organize them in a dedicated folder (for example <code>hooks/</code>).</p>"},{"location":"LTF_LIBS/ltf.hooks/#api-reference","title":"API reference","text":"<p>All hook callbacks have the same signature:</p> <ul> <li><code>fn(context)</code> where <code>context</code> is of type <code>context_t</code></li> </ul> <p>You can register as many hooks as you want for each hook type. They will run in the order they were registered.</p>"},{"location":"LTF_LIBS/ltf.hooks/#hook-registration","title":"Hook registration","text":""},{"location":"LTF_LIBS/ltf.hooks/#ltfhookstest_run_startedfn","title":"<code>ltf.hooks.test_run_started(fn)</code>","text":"<p>Registers a callback that runs once at the start of the whole test run.</p> <p>Parameters:</p> <ul> <li><code>fn</code> (<code>hooks_fn</code>): <code>function(context) ... end</code></li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal hooks = ltf.hooks\n\nhooks.test_run_started(function(ctx)\n  ltf.log_info(\"Run started for project:\", ctx.test_run.project_name)\n  ltf.log_info(\"Tags:\", table.concat(ctx.test_run.tags, \", \"))\nend)\n</code></pre>"},{"location":"LTF_LIBS/ltf.hooks/#ltfhookstest_startedfn","title":"<code>ltf.hooks.test_started(fn)</code>","text":"<p>Registers a callback that runs before each test starts.</p> <p>Parameters:</p> <ul> <li><code>fn</code> (<code>hooks_fn</code>)</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal hooks = ltf.hooks\n\nhooks.test_started(function(ctx)\n  ltf.log_info(\"Starting test:\", ctx.test.name)\nend)\n</code></pre>"},{"location":"LTF_LIBS/ltf.hooks/#ltfhookstest_finishedfn","title":"<code>ltf.hooks.test_finished(fn)</code>","text":"<p>Registers a callback that runs after each test finishes.</p> <p>Parameters:</p> <ul> <li><code>fn</code> (<code>hooks_fn</code>)</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal hooks = ltf.hooks\n\nhooks.test_finished(function(ctx)\n  ltf.log_info(\"Finished test:\", ctx.test.name, \"status:\", tostring(ctx.test.status))\nend)\n</code></pre>"},{"location":"LTF_LIBS/ltf.hooks/#ltfhookstest_run_finishedfn","title":"<code>ltf.hooks.test_run_finished(fn)</code>","text":"<p>Registers a callback that runs once after all tests have finished.</p> <p>Parameters:</p> <ul> <li><code>fn</code> (<code>hooks_fn</code>)</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal hooks = ltf.hooks\n\nhooks.test_run_finished(function(ctx)\n  ltf.log_info(\"Run finished. Logs dir:\", ctx.log_dir)\n  ltf.log_info(\"Started:\", ctx.test_run.started, \"Finished:\", tostring(ctx.test_run.finished))\nend)\n</code></pre>"},{"location":"LTF_LIBS/ltf.hooks/#context-types","title":"Context types","text":""},{"location":"LTF_LIBS/ltf.hooks/#context_t","title":"<code>context_t</code>","text":"<p>The object passed to every hook.</p> <ul> <li><code>test_run</code> (<code>test_run_context_t</code>): run-level metadata</li> <li><code>test</code> (<code>test_context_t</code>): current test metadata (for run hooks, this may reflect the \u201ccurrent\u201d/last test depending on when it\u2019s invoked)</li> <li><code>log_dir</code> (<code>string</code>): path to the test run log directory</li> </ul>"},{"location":"LTF_LIBS/ltf.hooks/#test_run_context_t","title":"<code>test_run_context_t</code>","text":"<p>Run-level metadata:</p> <ul> <li><code>project_name</code> (<code>string</code>)</li> <li><code>ltf_version</code> (<code>string</code>)</li> <li><code>started</code> (<code>string</code>)</li> <li><code>finished</code> (<code>string?</code>): <code>nil</code> until the run is finished</li> <li><code>os</code> (<code>string</code>)</li> <li><code>os_version</code> (<code>string</code>)</li> <li><code>target</code> (<code>string?</code>): set if multi-target run</li> <li><code>tags</code> (<code>string[]</code>): active run tags</li> </ul>"},{"location":"LTF_LIBS/ltf.hooks/#test_context_t","title":"<code>test_context_t</code>","text":"<p>Per-test metadata:</p> <ul> <li><code>test_file</code> (<code>string</code>)</li> <li><code>name</code> (<code>string</code>)</li> <li><code>started</code> (<code>string</code>)</li> <li><code>finished</code> (<code>string?</code>): <code>nil</code> until finished</li> <li><code>status</code> (<code>\"passed\"|\"failed\"|nil</code>): <code>nil</code> until finished</li> <li><code>tags</code> (<code>string[]</code>)</li> <li><code>output</code> (<code>test_output_t[]</code>)</li> <li><code>failure_reasons</code> (<code>test_output_t[]</code>)</li> <li><code>teardown_output</code> (<code>test_output_t[]</code>)</li> <li><code>teardown_errors</code> (<code>test_output_t[]</code>)</li> <li><code>keywords</code> (<code>test_keyword_t[]</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.hooks/#test_output_t","title":"<code>test_output_t</code>","text":"<p>A single log/output entry:</p> <ul> <li><code>file</code> (<code>string</code>)</li> <li><code>line</code> (<code>integer</code>)</li> <li><code>date_time</code> (<code>string</code>)</li> <li><code>level</code> (<code>\"CRITICAL\"|\"ERROR\"|\"WARNING\"|\"INFO\"|\"DEBUG\"|\"TRACE\"</code>)</li> <li><code>msg</code> (<code>string</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.hooks/#test_keyword_t","title":"<code>test_keyword_t</code>","text":"<p>Keyword tree entries (call-stack-like information):</p> <ul> <li><code>name</code> (<code>string</code>)</li> <li><code>started</code> (<code>string</code>)</li> <li><code>finished</code> (<code>string</code>)</li> <li><code>file</code> (<code>string</code>)</li> <li><code>line</code> (<code>integer</code>)</li> <li><code>children</code> (<code>test_keyword_t[]</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.hooks/#type-reference-lua-annotations","title":"Type reference (Lua annotations)","text":"<pre><code>--- @alias hooks_fn fun(context: context_t)\n\n--- @class context_t\n--- @field test_run test_run_context_t\n--- @field test test_context_t\n--- @field log_dir string\n</code></pre>"},{"location":"LTF_LIBS/ltf.http/","title":"HTTP Client (<code>ltf.http</code>)","text":"<p><code>ltf.http</code> is a low-level HTTP client built as a thin wrapper around libcurl. You create a handle, configure it using <code>setopt()</code>, perform the transfer, and then clean up the handle.</p>"},{"location":"LTF_LIBS/ltf.http/#getting-started","title":"Getting started","text":"<p><code>http</code> is exposed as a submodule of <code>ltf</code>:</p> <pre><code>local ltf = require(\"ltf\")\nlocal http = ltf.http\n</code></pre>"},{"location":"LTF_LIBS/ltf.http/#api-reference","title":"API reference","text":"<p>The typical request flow is:</p> <ol> <li>Create a handle with <code>http.new()</code></li> <li>Configure it with <code>handle:setopt(...)</code></li> <li>Execute with <code>handle:perform()</code></li> <li>Release resources with <code>handle:cleanup()</code> (recommended via <code>ltf.defer</code>)</li> </ol>"},{"location":"LTF_LIBS/ltf.http/#handle-management","title":"Handle management","text":""},{"location":"LTF_LIBS/ltf.http/#ltfhttpnew","title":"<code>ltf.http.new()</code>","text":"<p>Creates and returns a new HTTP handle.</p> <p>Returns:</p> <ul> <li>(<code>http_handle</code>): a new <code>http_handle</code> object</li> </ul>"},{"location":"LTF_LIBS/ltf.http/#the-http_handle-object","title":"The <code>http_handle</code> object","text":""},{"location":"LTF_LIBS/ltf.http/#handlesetoptcurlopt-value-http_handle","title":"<code>handle:setopt(curlopt, value) -&gt; http_handle</code>","text":"<p>Sets a libcurl option on the handle. This method is chainable.</p> <p>Parameters:</p> <ul> <li><code>curlopt</code> (<code>integer</code>): one of the <code>http.OPT_*</code> constants</li> <li><code>value</code> (<code>boolean|integer|string|string[]|function</code>): option value</li> </ul> <p>Returns:</p> <ul> <li>(<code>http_handle</code>): the same handle (for chaining)</li> </ul>"},{"location":"LTF_LIBS/ltf.http/#handleperform","title":"<code>handle:perform()</code>","text":"<p>Performs the transfer (blocking).</p>"},{"location":"LTF_LIBS/ltf.http/#handlecleanup","title":"<code>handle:cleanup()</code>","text":"<p>Frees resources associated with the handle. You should call this for every handle you create.</p>"},{"location":"LTF_LIBS/ltf.http/#option-constants-httpopt_","title":"Option constants (<code>http.OPT_*</code>)","text":"<p><code>ltf.http</code> exports many <code>OPT_*</code> constants that map directly to libcurl <code>CURLOPT_*</code> options.</p> <p>For detailed meaning of each option, refer to the official curl docs for <code>curl_easy_setopt</code>.</p> <p>Below are some commonly used options:</p> <ul> <li><code>OPT_URL</code> (<code>string</code>) \u2014 request URL</li> <li><code>OPT_FOLLOWLOCATION</code> (<code>boolean|integer</code>) \u2014 follow redirects</li> <li><code>OPT_VERBOSE</code> (<code>boolean|integer</code>) \u2014 enable verbose curl output</li> <li><code>OPT_TIMEOUT_MS</code> (<code>integer</code>) \u2014 total timeout in milliseconds</li> <li><code>OPT_POST</code> (<code>boolean|integer</code>) \u2014 enable POST</li> <li><code>OPT_POSTFIELDS</code> (<code>string</code>) \u2014 POST body</li> <li><code>OPT_HTTPHEADER</code> (<code>string[]</code>) \u2014 list of headers (<code>{ \"Header: value\", ... }</code>)</li> <li><code>OPT_CUSTOMREQUEST</code> (<code>string</code>) \u2014 custom method (<code>\"PUT\"</code>, <code>\"DELETE\"</code>, ...)</li> <li><code>OPT_WRITEFUNCTION</code> (<code>function</code>) \u2014 body callback</li> <li><code>OPT_HEADERFUNCTION</code> (<code>function</code>) \u2014 header callback</li> <li><code>OPT_SSL_VERIFYPEER</code> (<code>boolean|integer</code>) \u2014 enable/disable cert verification</li> </ul> <p>Note: some options are defined as \u201clong\u201d by curl and may expect <code>0/1</code> instead of Lua booleans. In practice, both are commonly accepted by wrappers\u2014if you hit type issues, pass <code>0</code> or <code>1</code>.</p>"},{"location":"LTF_LIBS/ltf.http/#examples","title":"Examples","text":""},{"location":"LTF_LIBS/ltf.http/#simple-get-request","title":"Simple GET request","text":"<p>This example captures the response body into a Lua string.</p> <pre><code>local ltf = require(\"ltf\")\nlocal http = ltf.http\n\nltf.test({\n  name = \"Simple GET request\",\n  body = function()\n    local parts = {}\n\n    local handle = http.new()\n    ltf.defer(handle.cleanup, handle)\n\n    handle:setopt(http.OPT_URL, \"https://api.github.com/zen\")\n    handle:setopt(http.OPT_USERAGENT, \"LTF-HTTP-Client/1.0\")\n\n    handle:setopt(http.OPT_WRITEFUNCTION, function(data)\n      table.insert(parts, data)\n      return #data\n    end)\n\n    ltf.log_info(\"Performing GET request...\")\n    handle:perform()\n    ltf.log_info(\"Request finished.\")\n\n    local body = table.concat(parts)\n    ltf.print(\"Response:\", body)\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.http/#post-json-with-headers","title":"POST JSON with headers","text":"<p>This example posts JSON and captures both headers and body.</p> <pre><code>local ltf = require(\"ltf\")\nlocal http = ltf.http\n\nltf.test({\n  name = \"POST JSON data\",\n  body = function()\n    local response_headers = {}\n    local response_body_parts = {}\n\n    local post_data = ltf.json.serialize({\n      title = \"My LTF Test Post\",\n      body = \"This is a test from the LTF framework.\",\n      userId = 1,\n    })\n\n    local handle = http.new()\n    ltf.defer(handle.cleanup, handle)\n\n    handle:setopt(http.OPT_URL, \"https://jsonplaceholder.typicode.com/posts\")\n      :setopt(http.OPT_POST, 1)\n      :setopt(http.OPT_POSTFIELDS, post_data)\n      :setopt(http.OPT_HTTPHEADER, {\n        \"Content-Type: application/json; charset=UTF-8\",\n        \"Accept: application/json\",\n      })\n      :setopt(http.OPT_HEADERFUNCTION, function(line)\n        table.insert(response_headers, (line:gsub(\"[\\r\\n]\", \"\")))\n        return true\n      end)\n      :setopt(http.OPT_WRITEFUNCTION, function(data)\n        table.insert(response_body_parts, data)\n        return #data\n      end)\n\n    ltf.log_info(\"Performing POST request...\")\n    handle:perform()\n    ltf.log_info(\"Request finished.\")\n\n    local response_body = table.concat(response_body_parts)\n\n    ltf.log_debug(\"--- Response Headers ---\")\n    for _, h in ipairs(response_headers) do\n      if #h &gt; 0 then\n        ltf.log_debug(h)\n      end\n    end\n\n    ltf.log_debug(\"--- Response Body ---\")\n    ltf.print(response_body)\n\n    local decoded = ltf.json.deserialize(response_body)\n    if decoded and decoded.id then\n      ltf.log_info(\"Successfully created post with ID:\", decoded.id)\n    else\n      ltf.log_error(\"Failed to parse response or find ID.\")\n    end\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.http/#low-level-access","title":"Low-level access","text":""},{"location":"LTF_LIBS/ltf.http/#ltfhttplow","title":"<code>ltf.http.low</code>","text":"<p><code>http.low</code> exposes the underlying low-level module (<code>require(\"ltf-http\")</code>). Most users should use <code>http.new()</code> + <code>handle:setopt()</code> + <code>handle:perform()</code>.</p>"},{"location":"LTF_LIBS/ltf.http/#type-reference-lua-annotations","title":"Type reference (Lua annotations)","text":"<pre><code>--- @class http_handle\n--- @field setopt fun(self: http_handle, curlopt: integer, value: boolean|integer|string|string[]|function): http_handle\n--- @field perform fun(self: http_handle)\n--- @field cleanup fun(self: http_handle)\n</code></pre>"},{"location":"LTF_LIBS/ltf.json/","title":"JSON Utilities (<code>ltf.json</code>)","text":"<p><code>ltf.json</code> provides fast helpers for serializing Lua values to JSON strings and deserializing JSON strings back into Lua tables.</p>"},{"location":"LTF_LIBS/ltf.json/#getting-started","title":"Getting started","text":"<p><code>json</code> is exposed as a submodule of <code>ltf</code>:</p> <pre><code>local ltf = require(\"ltf\")\nlocal json = ltf.json\n</code></pre>"},{"location":"LTF_LIBS/ltf.json/#api-reference","title":"API reference","text":""},{"location":"LTF_LIBS/ltf.json/#ltfjsonserializeobject-opts","title":"<code>ltf.json.serialize(object, opts)</code>","text":"<p>Converts a Lua value (typically a table) into a JSON string.</p> <p>Parameters:</p> <ul> <li><code>object</code> (<code>any</code>): Lua value to serialize</li> <li><code>opts</code> (<code>json_serialize_opts</code>, optional): formatting/behavior options</li> </ul> <p>Returns:</p> <ul> <li>(<code>string</code>): JSON string</li> </ul>"},{"location":"LTF_LIBS/ltf.json/#json_serialize_opts-table","title":"<code>json_serialize_opts</code> (table)","text":"Field Type Default Description <code>pretty</code> <code>boolean</code> <code>false</code> Pretty-print with indentation (2 spaces). <code>pretty_tab</code> <code>boolean</code> <code>false</code> If <code>pretty</code> is true, indent with tabs instead of spaces. <code>spaced</code> <code>boolean</code> <code>false</code> Add extra spaces where appropriate (more human-readable). <code>color</code> <code>boolean</code> <code>false</code> Add terminal escape codes to colorize the JSON output. <code>no_trailing_zero</code> <code>boolean</code> <code>false</code> Remove trailing zeros from floats (e.g. <code>1.200</code> \u2192 <code>1.2</code>). <code>slash_escape</code> <code>boolean</code> <code>false</code> Escape <code>/</code> characters (e.g. <code>/</code> \u2192 <code>\\/</code>). <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal json = ltf.json\n\nltf.test({\n  name = \"JSON serialization\",\n  body = function()\n    local my_data = {\n      name = \"LTF Test\",\n      id = 123,\n      active = true,\n      tags = { \"core\", \"api\" },\n      path = \"c:/temp/data\",\n    }\n\n    local compact = json.serialize(my_data)\n    ltf.print(\"Compact JSON:\", compact)\n\n    local pretty = json.serialize(my_data, { pretty = true, slash_escape = true })\n    ltf.print(\"Pretty JSON with escaped slashes:\")\n    ltf.print(pretty)\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.json/#ltfjsondeserializestr","title":"<code>ltf.json.deserialize(str)</code>","text":"<p>Parses a JSON string into a Lua table.</p> <p>Parameters:</p> <ul> <li><code>str</code> (<code>string</code>): JSON string to parse</li> </ul> <p>Returns:</p> <ul> <li>(<code>table</code>): parsed Lua object</li> </ul> <p>Errors:</p> <ul> <li>Raises an error if the JSON is invalid.</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal json = ltf.json\n\nltf.test({\n  name = \"JSON deserialization\",\n  body = function()\n    local json_string = '{\"user\":\"test_user\",\"permissions\":[\"read\",\"write\"],\"session_id\":98765}'\n    local data = json.deserialize(json_string)\n\n    ltf.print(\"User:\", data.user)\n    ltf.print(\"First permission:\", data.permissions[1])\n\n    if data.session_id &gt; 90000 then\n      ltf.log_info(\"High session ID detected.\")\n    end\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.json/#low-level-access","title":"Low-level access","text":""},{"location":"LTF_LIBS/ltf.json/#ltfjsonlow","title":"<code>ltf.json.low</code>","text":"<p><code>json.low</code> exposes the underlying low-level module (<code>require(\"ltf-json\")</code>). Most users should use <code>json.serialize()</code> / <code>json.deserialize()</code>.</p>"},{"location":"LTF_LIBS/ltf.json/#type-reference-lua-annotations","title":"Type reference (Lua annotations)","text":"<pre><code>--- @class json_serialize_opts\n--- @field spaced boolean?\n--- @field pretty boolean?\n--- @field pretty_tab boolean?\n--- @field no_trailing_zero boolean?\n--- @field slash_escape boolean?\n--- @field color boolean?\n</code></pre>"},{"location":"LTF_LIBS/ltf/","title":"LTF Core Library (<code>ltf</code>)","text":"<p><code>ltf</code> is the main Lua entry point for writing tests. It provides:</p> <ul> <li>Test registration (<code>ltf.test</code>)</li> <li>Logging helpers (<code>ltf.log_*</code>, <code>ltf.print</code>)</li> <li>Timing and utilities (<code>ltf.sleep</code>, <code>ltf.millis</code>, <code>ltf.defer</code>)</li> <li>Run/test context helpers (<code>ltf.get_active_tags</code>, <code>ltf.get_active_test_tags</code>, <code>ltf.get_current_target</code>)</li> <li>Variable + secret APIs (<code>ltf.register_vars</code>, <code>ltf.get_var</code>, <code>ltf.get_vars</code>, <code>ltf.register_secrets</code>, <code>ltf.get_secret</code>, <code>ltf.get_secrets</code>)</li> <li>Submodules (<code>ltf.serial</code>, <code>ltf.http</code>, <code>ltf.ssh</code>, <code>ltf.webdriver</code>, etc.)</li> </ul>"},{"location":"LTF_LIBS/ltf/#getting-started","title":"Getting started","text":"<p>In any Lua test file:</p> <pre><code>local ltf = require(\"ltf\")\n</code></pre>"},{"location":"LTF_LIBS/ltf/#modules","title":"Modules","text":"<p>The <code>ltf</code> module exposes several submodules:</p> <ul> <li><code>ltf.serial</code></li> <li><code>ltf.webdriver</code></li> <li><code>ltf.proc</code></li> <li><code>ltf.json</code></li> <li><code>ltf.http</code></li> <li><code>ltf.hooks</code></li> <li><code>ltf.ssh</code></li> <li><code>ltf.util</code></li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\n\nlocal serial = ltf.serial\n-- serial.open(...), etc.\n</code></pre>"},{"location":"LTF_LIBS/ltf/#api-reference","title":"API reference","text":""},{"location":"LTF_LIBS/ltf/#defining-tests","title":"Defining tests","text":""},{"location":"LTF_LIBS/ltf/#ltftestopts","title":"<code>ltf.test(opts)</code>","text":"<p>Registers a new test.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>ltf_test_opts</code>): test options object:</p> </li> <li> <p><code>name</code> (<code>string</code>, required): test name (must be unique within a run)</p> </li> <li><code>description</code> (<code>string</code>, optional): human-readable description</li> <li><code>tags</code> (<code>string[]</code>, optional): tags for filtering</li> <li><code>body</code> (<code>function</code>, required): test function</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\n\nltf.test({\n  name = \"My first test\",\n  tags = { \"smoke\", \"api\" },\n  body = function()\n    ltf.log_info(\"Hello from LTF\")\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf/#logging","title":"Logging","text":"<p>All logs are written to the log files and shown in the TUI.</p>"},{"location":"LTF_LIBS/ltf/#ltfloglevel","title":"<code>ltf.log(level, ...)</code>","text":"<p>Logs a message at the specified level.</p> <p>Parameters:</p> <ul> <li> <p><code>level</code> (<code>log_level</code>): accepted values are:</p> </li> <li> <p>Full names: <code>\"critical\"</code>, <code>\"error\"</code>, <code>\"warning\"</code>, <code>\"info\"</code>, <code>\"debug\"</code>, <code>\"trace\"</code></p> </li> <li>First-letter shortcuts: <code>\"c\"</code>, <code>\"e\"</code>, <code>\"w\"</code>, <code>\"i\"</code>, <code>\"d\"</code>, <code>\"t\"</code></li> <li>Case-insensitive (e.g. <code>\"INFO\"</code>, <code>\"C\"</code>)</li> <li><code>...</code> (<code>any</code>): values to log (like Lua <code>print()</code>)</li> </ul> <p>Behavior:</p> <ul> <li><code>\"critical\"</code>: fails the test immediately.</li> <li><code>\"error\"</code>: marks the test failed but continues execution.</li> <li>Other levels only log.</li> </ul> <p>Example:</p> <pre><code>ltf.test({\n  name = \"Logging demonstration\",\n  body = function()\n    ltf.print(\"Same as info\")\n    ltf.log_debug(\"Debug details:\", 123)\n\n    ltf.log_error(\"This fails the test, but continues.\")\n    ltf.log_info(\"This still runs.\")\n\n    -- ltf.log_critical(\"Stops immediately.\")\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf/#convenience-helpers","title":"Convenience helpers","text":"<ul> <li><code>ltf.print(...)</code> \u2014 same as <code>ltf.log(\"i\", ...)</code></li> <li><code>ltf.log_critical(...)</code> \u2014 same as <code>ltf.log(\"c\", ...)</code> (fails immediately)</li> <li><code>ltf.log_error(...)</code> \u2014 same as <code>ltf.log(\"e\", ...)</code> (marks failed, continues)</li> <li><code>ltf.log_warning(...)</code> \u2014 same as <code>ltf.log(\"w\", ...)</code></li> <li><code>ltf.log_info(...)</code> \u2014 same as <code>ltf.log(\"i\", ...)</code></li> <li><code>ltf.log_debug(...)</code> \u2014 same as <code>ltf.log(\"d\", ...)</code></li> <li><code>ltf.log_trace(...)</code> \u2014 same as <code>ltf.log(\"t\", ...)</code></li> </ul>"},{"location":"LTF_LIBS/ltf/#test-control-and-utilities","title":"Test control and utilities","text":""},{"location":"LTF_LIBS/ltf/#ltfdeferfn","title":"<code>ltf.defer(fn, ...)</code>","text":"<p>Registers a function to be executed after the test finishes (teardown). This is useful for cleanup.</p> <p>Parameters:</p> <ul> <li><code>fn</code> (<code>function</code>): function to call during teardown</li> <li><code>...</code> (<code>any</code>): arguments passed to <code>fn</code></li> </ul> <p>Example:</p> <pre><code>ltf.test({\n  name = \"Defer demonstration\",\n  body = function()\n    local port = open_very_important_port()\n    ltf.defer(close_port, port)\n\n    ltf.defer(function()\n      ltf.log_info(\"Always runs at the end of the test.\")\n    end)\n\n    ltf.log_info(\"Test body runs here.\")\n  end,\n})\n</code></pre> <p>Note: defers execute after the test finishes. (If you rely on specific ordering like LIFO/FIFO, document the current behavior in your runtime, because it\u2019s not defined by this Lua wrapper file.)</p>"},{"location":"LTF_LIBS/ltf/#ltfsleepms","title":"<code>ltf.sleep(ms)</code>","text":"<p>Sleeps for <code>ms</code> milliseconds.</p> <ul> <li><code>ms</code> (<code>number</code>): milliseconds</li> </ul> <pre><code>ltf.sleep(250)\n</code></pre>"},{"location":"LTF_LIBS/ltf/#ltfmillis-integer","title":"<code>ltf.millis() -&gt; integer</code>","text":"<p>Returns milliseconds elapsed since the current test started.</p> <pre><code>local elapsed = ltf.millis()\nltf.log_info(\"Elapsed:\", elapsed, \"ms\")\n</code></pre>"},{"location":"LTF_LIBS/ltf/#run-context-helpers","title":"Run context helpers","text":""},{"location":"LTF_LIBS/ltf/#ltfget_active_tags-string","title":"<code>ltf.get_active_tags() -&gt; string[]</code>","text":"<p>Returns the active tags for the current test run.</p>"},{"location":"LTF_LIBS/ltf/#ltfget_active_test_tags-string","title":"<code>ltf.get_active_test_tags() -&gt; string[]</code>","text":"<p>Returns the active tags for the currently running test.</p>"},{"location":"LTF_LIBS/ltf/#ltfget_current_target-string","title":"<code>ltf.get_current_target() -&gt; string</code>","text":"<p>Returns the current target name if the project is multi-target, otherwise returns <code>\"\"</code>.</p>"},{"location":"LTF_LIBS/ltf/#variables","title":"Variables","text":"<p>Variables are named values used across tests and can be set via CLI/scenarios.</p>"},{"location":"LTF_LIBS/ltf/#ltfregister_varsvars","title":"<code>ltf.register_vars(vars)</code>","text":"<p>Registers variables at Lua top level.</p> <ul> <li><code>vars</code> (<code>table&lt;string, ltf_var_reg_t|string&gt;</code>)</li> </ul> <p>A variable may be registered as a constant string or as a table with:</p> <ul> <li><code>default</code> (<code>string</code>, optional)</li> <li><code>values</code> (<code>string[]</code>, optional)</li> </ul> <pre><code>ltf.register_vars({\n  -- constant\n  device = \"stm32wb55\",\n\n  -- required / open value\n  serial_port = {},\n\n  -- default\n  baud = { default = \"115200\" },\n\n  -- enum\n  env = { values = { \"dev\", \"staging\", \"prod\" } },\n\n  -- enum + default\n  log_level = { default = \"info\", values = { \"info\", \"debug\", \"trace\" } },\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf/#ltfget_varname-string","title":"<code>ltf.get_var(name) -&gt; string</code>","text":"<p>Returns a single variable value.</p> <pre><code>local port = ltf.get_var(\"serial_port\")\n</code></pre>"},{"location":"LTF_LIBS/ltf/#ltfget_var_numbername-number","title":"<code>ltf.get_var_number(name) -&gt; number</code>","text":"<p>Returns a single variable value as a number.</p> <pre><code>local port_number = ltf.get_var_number(\"port_number\")\n</code></pre>"},{"location":"LTF_LIBS/ltf/#ltfget_vars-tablestring-string","title":"<code>ltf.get_vars() -&gt; table&lt;string, string&gt;</code>","text":"<p>Returns all variables as a map of <code>name -&gt; value</code>.</p>"},{"location":"LTF_LIBS/ltf/#secrets","title":"Secrets","text":"<p>Secrets are named sensitive values loaded from <code>.secrets</code>.</p>"},{"location":"LTF_LIBS/ltf/#ltfregister_secretsnames","title":"<code>ltf.register_secrets(names)</code>","text":"<p>Registers secret names at Lua top level.</p> <ul> <li><code>names</code> (<code>string[]</code>)</li> </ul> <pre><code>ltf.register_secrets({ \"api_token\", \"password\" })\n</code></pre>"},{"location":"LTF_LIBS/ltf/#ltfget_secretname-string","title":"<code>ltf.get_secret(name) -&gt; string</code>","text":"<p>Returns a single secret value.</p> <pre><code>local token = ltf.get_secret(\"api_token\")\n</code></pre>"},{"location":"LTF_LIBS/ltf/#ltfget_secrets-tablestring-string","title":"<code>ltf.get_secrets() -&gt; table&lt;string, string&gt;</code>","text":"<p>Returns all secrets as a map of <code>name -&gt; value</code>.</p>"},{"location":"LTF_LIBS/ltf.proc/","title":"Process Management (<code>ltf.proc</code>)","text":"<p><code>ltf.proc</code> provides helpers for running and interacting with external system processes. You can:</p> <ul> <li>Run a command and wait for it to finish (<code>proc.run</code>)</li> <li>Spawn a process and interact with it asynchronously (<code>proc.spawn</code>)</li> <li>Access the low-level backend module via <code>proc.low</code></li> </ul>"},{"location":"LTF_LIBS/ltf.proc/#getting-started","title":"Getting started","text":"<p><code>proc</code> is exposed as a submodule of <code>ltf</code>:</p> <pre><code>local ltf = require(\"ltf\")\nlocal proc = ltf.proc\n</code></pre>"},{"location":"LTF_LIBS/ltf.proc/#api-reference","title":"API reference","text":""},{"location":"LTF_LIBS/ltf.proc/#high-level-execution","title":"High-level execution","text":""},{"location":"LTF_LIBS/ltf.proc/#ltfprocrunopts-timeout-sleepinterval","title":"<code>ltf.proc.run(opts, timeout, sleepinterval)</code>","text":"<p>Runs an external command, waits for it to complete (optionally with a timeout), and returns captured <code>stdout</code>, <code>stderr</code>, and <code>exitcode</code>.</p> <p>Parameters:</p> <ul> <li><code>opts</code> (<code>run_opts</code>): executable + args</li> <li><code>timeout</code> (<code>integer</code>, optional): timeout in milliseconds. If <code>nil</code>, waits indefinitely.</li> <li><code>sleepinterval</code> (<code>integer</code>, optional): interval (ms) between timeout checks. Default: <code>20</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>result</code> (<code>run_result</code>): <code>{ stdout, stderr, exitcode }</code></li> </ul> <p>Errors:</p> <ul> <li>Throws a Lua error with message <code>\"timeout\"</code> if the timeout is reached.</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal proc = ltf.proc\n\nltf.test({\n  name = \"Run a git command\",\n  body = function()\n    local ok, result_or_err = pcall(function()\n      return proc.run({\n        exe = \"git\",\n        args = { \"--version\" },\n      }, 2000) -- 2-second timeout\n    end)\n\n    if not ok then\n      if result_or_err == \"timeout\" then\n        ltf.log_critical(\"Command timed out\")\n      else\n        ltf.log_critical(\"Command failed:\", result_or_err)\n      end\n    end\n\n    local result = result_or_err\n    if result.exitcode == 0 then\n      ltf.log_info(\"Git command successful!\")\n      ltf.print(\"Output:\", result.stdout)\n    else\n      ltf.log_error(\"Git command failed with code:\", result.exitcode)\n      ltf.print(\"Error output:\", result.stderr)\n    end\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.proc/#asynchronous-spawning","title":"Asynchronous spawning","text":""},{"location":"LTF_LIBS/ltf.proc/#ltfprocspawnopts","title":"<code>ltf.proc.spawn(opts)</code>","text":"<p>Spawns an external process and returns a <code>proc_handle</code> for interacting with it while it is running.</p> <p>Parameters:</p> <ul> <li><code>opts</code> (<code>run_opts</code>): executable + args</li> </ul> <p>Returns:</p> <ul> <li>(<code>proc_handle</code>): process handle with <code>read</code>, <code>write</code>, <code>wait</code>, <code>kill</code></li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal proc = ltf.proc\n\nltf.test({\n  name = \"Interact with a running process\",\n  body = function()\n    local handle = proc.spawn({\n      exe = \"grep\",\n      args = { \"Hello\" },\n    })\n\n    -- Ensure cleanup\n    ltf.defer(handle.kill, handle)\n\n    handle:write(\"Line 1\\n\")\n    handle:write(\"Hello World\\n\")\n    handle:write(\"Line 3\\n\")\n\n    -- Close stdin (platform/process dependent; example kept as-is)\n    handle:write(\"\")\n\n    while handle:wait() == nil do\n      ltf.sleep(50)\n    end\n\n    local output = handle:read(\"stdout\")\n    ltf.log_info(\"Grep found:\", output)\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.proc/#the-proc_handle-object","title":"The <code>proc_handle</code> object","text":"<p>Returned by <code>ltf.proc.spawn()</code>.</p>"},{"location":"LTF_LIBS/ltf.proc/#handlereadstream-want-string","title":"<code>handle:read(stream?, want?) -&gt; string</code>","text":"<p>Reads from stdout/stderr.</p> <p>Parameters:</p> <ul> <li><code>stream</code> (<code>proc_output_stream</code>, optional): <code>\"stdout\"</code> (default) or <code>\"stderr\"</code></li> <li><code>want</code> (<code>integer</code>, optional): number of bytes requested (default <code>4096</code>)</li> </ul> <p>Returns:</p> <ul> <li>(<code>string</code>): bytes read</li> </ul> <p>Note: <code>read()</code> must not be called after <code>kill()</code>.</p>"},{"location":"LTF_LIBS/ltf.proc/#handlewritebuf-integer","title":"<code>handle:write(buf) -&gt; integer</code>","text":"<p>Writes to stdin (if the process is still alive).</p> <p>Parameters:</p> <ul> <li><code>buf</code> (<code>string</code>): data to write</li> </ul> <p>Returns:</p> <ul> <li>(<code>integer</code>): number of bytes written</li> </ul>"},{"location":"LTF_LIBS/ltf.proc/#handlewait-integer","title":"<code>handle:wait() -&gt; integer?</code>","text":"<p>Non-blocking status check.</p> <p>Returns:</p> <ul> <li>(<code>integer</code>): exit code if process has finished</li> <li>(<code>nil</code>): if still running</li> </ul>"},{"location":"LTF_LIBS/ltf.proc/#handlekill","title":"<code>handle:kill()</code>","text":"<p>Sends <code>SIGINT</code> to the process if it\u2019s still running.</p>"},{"location":"LTF_LIBS/ltf.proc/#low-level-access","title":"Low-level access","text":""},{"location":"LTF_LIBS/ltf.proc/#ltfproclow","title":"<code>ltf.proc.low</code>","text":"<p><code>proc.low</code> exposes the underlying low-level module (<code>require(\"ltf-proc\")</code>). Most users should prefer <code>proc.spawn()</code> / <code>proc.run()</code>.</p>"},{"location":"LTF_LIBS/ltf.proc/#data-structures-types","title":"Data structures &amp; types","text":""},{"location":"LTF_LIBS/ltf.proc/#run_opts-table","title":"<code>run_opts</code> (table)","text":"<ul> <li><code>exe</code> (<code>string</code>): executable path or name (if on <code>PATH</code>)</li> <li><code>args</code> (<code>string[]</code>, optional): command-line arguments</li> </ul>"},{"location":"LTF_LIBS/ltf.proc/#run_result-table","title":"<code>run_result</code> (table)","text":"<ul> <li><code>stdout</code> (<code>string</code>): captured stdout</li> <li><code>stderr</code> (<code>string</code>): captured stderr</li> <li><code>exitcode</code> (<code>integer</code>): process exit code</li> </ul>"},{"location":"LTF_LIBS/ltf.proc/#proc_output_stream-alias","title":"<code>proc_output_stream</code> (alias)","text":"<ul> <li><code>\"stdout\"</code> (default)</li> <li><code>\"stderr\"</code></li> </ul>"},{"location":"LTF_LIBS/ltf.serial/","title":"Serial Communication (<code>ltf.serial</code>)","text":"<p><code>ltf.serial</code> provides an interface for communicating with serial port devices (COM ports or <code>/dev/tty*</code>). It can list available ports, open/configure a port, and perform read/write operations.</p>"},{"location":"LTF_LIBS/ltf.serial/#getting-started","title":"Getting started","text":"<p><code>serial</code> is exposed as a submodule of <code>ltf</code>:</p> <pre><code>local ltf = require(\"ltf\")\nlocal serial = ltf.serial\n</code></pre>"},{"location":"LTF_LIBS/ltf.serial/#api-reference","title":"API reference","text":""},{"location":"LTF_LIBS/ltf.serial/#device-discovery","title":"Device discovery","text":""},{"location":"LTF_LIBS/ltf.serial/#ltfseriallist_devices","title":"<code>ltf.serial.list_devices()</code>","text":"<p>Lists all serial ports detected on the system.</p> <p>Returns:</p> <ul> <li>(<code>serial_port_info[]</code>): array of <code>serial_port_info</code></li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal serial = ltf.serial\n\nltf.test({\n  name = \"List all serial ports\",\n  body = function()\n    local devices = serial.list_devices()\n    if #devices &gt; 0 then\n      ltf.print(\"Found\", #devices, \"serial devices:\")\n      for _, device in ipairs(devices) do\n        ltf.print((\"- %s (%s)\"):format(device.path, device.description))\n      end\n    else\n      ltf.log_warning(\"No serial devices found.\")\n    end\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.serial/#ltfserialget_portpath","title":"<code>ltf.serial.get_port(path)</code>","text":"<p>Gets a handle for a specific serial port by its path/name (e.g. <code>\"COM3\"</code> or <code>\"/dev/ttyUSB0\"</code>). This does not open the port.</p> <p>Parameters:</p> <ul> <li><code>path</code> (<code>string</code>): port path or name</li> </ul> <p>Returns:</p> <ul> <li>(<code>serial_port</code>): serial port handle</li> </ul>"},{"location":"LTF_LIBS/ltf.serial/#the-serial_port-object","title":"The <code>serial_port</code> object","text":"<p>The <code>serial_port</code> handle is returned by <code>ltf.serial.get_port(path)</code> and provides methods for configuring and communicating with the port.</p>"},{"location":"LTF_LIBS/ltf.serial/#portopenmode","title":"<code>port:open(mode)</code>","text":"<p>Opens the port.</p> <p>Parameters:</p> <ul> <li><code>mode</code> (<code>serial_mode</code>): <code>\"r\"</code>, <code>\"w\"</code>, or <code>\"rw\"</code></li> </ul>"},{"location":"LTF_LIBS/ltf.serial/#portclose","title":"<code>port:close()</code>","text":"<p>Closes the port. Recommended to call via <code>ltf.defer(...)</code>.</p>"},{"location":"LTF_LIBS/ltf.serial/#portreadchunk_size-string","title":"<code>port:read(chunk_size) -&gt; string</code>","text":"<p>Reads up to <code>chunk_size</code> bytes (non-blocking).</p>"},{"location":"LTF_LIBS/ltf.serial/#portwritedata-integer","title":"<code>port:write(data) -&gt; integer</code>","text":"<p>Writes data (non-blocking). Returns number of bytes written.</p>"},{"location":"LTF_LIBS/ltf.serial/#portread_untilopts-found-read","title":"<code>port:read_until(opts) -&gt; (found, read)</code>","text":"<p>Reads repeatedly until the pattern appears or timeout is reached.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>serial_read_until_opts</code>):</p> </li> <li> <p><code>pattern</code> (<code>string</code>, optional): literal string pattern (uses <code>string.find(..., true)</code>). Default: <code>\"\\n\"</code>.</p> </li> <li><code>timeout</code> (<code>integer</code>, optional): timeout in milliseconds. Default: <code>200</code>.</li> <li><code>chunk_size</code> (<code>integer</code>, optional): read chunk size. Default: <code>64</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>found</code> (<code>boolean</code>): <code>true</code> if pattern was found before timeout, <code>false</code> otherwise</li> <li><code>read</code> (<code>string</code>): everything that was read (always returned)</li> </ul>"},{"location":"LTF_LIBS/ltf.serial/#port-configuration-methods","title":"Port configuration methods","text":"<p>These configure the communication parameters:</p> <ul> <li><code>port:set_baudrate(baudrate)</code></li> <li><code>port:set_bits(bits)</code></li> <li><code>port:set_parity(parity)</code></li> <li><code>port:set_stopbits(stopbits)</code></li> <li><code>port:set_flowcontrol(flowctrl)</code></li> <li><code>port:set_rts(rts_option)</code></li> <li><code>port:set_dtr(dtr_option)</code></li> <li><code>port:set_cts(cts_option)</code></li> <li><code>port:set_dsr(dsr_option)</code></li> <li><code>port:set_xon_xoff(xonxoff_option)</code></li> </ul>"},{"location":"LTF_LIBS/ltf.serial/#port-status-control","title":"Port status &amp; control","text":"<ul> <li><code>port:flush(direction)</code></li> <li><code>port:drain()</code></li> <li><code>port:get_waiting_input() -&gt; integer</code></li> <li><code>port:get_waiting_output() -&gt; integer</code></li> <li><code>port:get_port_info() -&gt; serial_port_info</code></li> </ul>"},{"location":"LTF_LIBS/ltf.serial/#full-example","title":"Full example","text":"<pre><code>local ltf = require(\"ltf\")\nlocal serial = ltf.serial\n\nltf.test({\n  name = \"Communicate with GPS Device\",\n  tags = { \"hardware\", \"gps\" },\n  body = function()\n    local devices = serial.list_devices()\n\n    local gps_path = nil\n    for _, dev in ipairs(devices) do\n      if dev.product and dev.product:find(\"GPS\") then\n        gps_path = dev.path\n        break\n      end\n    end\n\n    if not gps_path then\n      ltf.log_critical(\"GPS device not found!\")\n    end\n\n    ltf.log_info(\"Found GPS device at:\", gps_path)\n\n    local port = serial.get_port(gps_path)\n    ltf.defer(port.close, port)\n\n    port:open(\"rw\")\n    port:set_baudrate(9600)\n    port:set_bits(8)\n    port:set_parity(\"none\")\n    port:set_stopbits(1)\n\n    ltf.print(\"Port configured. Waiting for NMEA sentence...\")\n\n    local found, data = port:read_until({\n      pattern = \"$GPGGA\",\n      timeout = 5000,\n      chunk_size = 64,\n    })\n\n    if found then\n      ltf.log_info(\"Received GPGGA sentence:\", data)\n    else\n      ltf.log_error(\"Did not receive a GPGGA sentence in time. Read:\", data)\n    end\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.serial/#data-structures-types","title":"Data structures &amp; types","text":""},{"location":"LTF_LIBS/ltf.serial/#serial_port_info-table","title":"<code>serial_port_info</code> (table)","text":"<p>Returned by <code>ltf.serial.list_devices()</code> and <code>port:get_port_info()</code>.</p> Field Type Description <code>path</code> <code>string</code> Path/name of the port (e.g. <code>COM3</code>, <code>/dev/ttyS0</code>). <code>type</code> <code>serial_port_type</code> <code>\"native\"</code>, <code>\"usb\"</code>, <code>\"bluetooth\"</code>, <code>\"unknown\"</code>. <code>description</code> <code>string</code> Human-readable description. <code>serial</code> <code>string?</code> USB serial number (if available). <code>product</code> <code>string?</code> USB product string (if available). <code>manufacturer</code> <code>string?</code> USB manufacturer string (if available). <code>vid</code> <code>number?</code> USB vendor ID (if available). <code>pid</code> <code>number?</code> USB product ID (if available). <code>usb_address</code> <code>number?</code> USB port address (if available). <code>usb_bus</code> <code>number?</code> USB bus number (if available). <code>bluetooth_address</code> <code>string?</code> Bluetooth MAC address (if available)."},{"location":"LTF_LIBS/ltf.serial/#type-aliases","title":"Type aliases","text":"Alias Accepted values Description <code>serial_mode</code> <code>\"r\"</code>, <code>\"w\"</code>, <code>\"rw\"</code> Read / Write / Read+Write. <code>serial_flush_direction</code> <code>\"i\"</code>, <code>\"o\"</code>, <code>\"io\"</code> Flush input / output / both. <code>serial_data_bits</code> <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code> Data bits. <code>serial_parity</code> <code>\"none\"</code>, <code>\"odd\"</code>, <code>\"even\"</code>, <code>\"mark\"</code>, <code>\"space\"</code> Parity mode. <code>serial_stop_bits</code> <code>1</code>, <code>2</code> Stop bits. <code>serial_flowctrl</code> <code>\"dtrdsr\"</code>, <code>\"rtscts\"</code>, <code>\"xonxoff\"</code>, <code>\"none\"</code> Flow control. <code>serial_rts</code> <code>\"off\"</code>, <code>\"on\"</code>, <code>\"flowctrl\"</code> RTS behavior. <code>serial_dtr</code> <code>\"off\"</code>, <code>\"on\"</code>, <code>\"flowctrl\"</code> DTR behavior. <code>serial_cts</code> <code>\"ignore\"</code>, <code>\"flowctrl\"</code> CTS behavior. <code>serial_dsr</code> <code>\"ignore\"</code>, <code>\"flowctrl\"</code> DSR behavior. <code>serial_xonxoff</code> <code>\"i\"</code>, <code>\"o\"</code>, <code>\"io\"</code>, <code>\"disable\"</code> XON/XOFF mode. <code>serial_port_type</code> <code>\"native\"</code>, <code>\"usb\"</code>, <code>\"bluetooth\"</code>, <code>\"unknown\"</code> Port connection type."},{"location":"LTF_LIBS/ltf.serial/#low-level-access","title":"Low-level access","text":""},{"location":"LTF_LIBS/ltf.serial/#ltfseriallow","title":"<code>ltf.serial.low</code>","text":"<p><code>serial.low</code> exposes the underlying low-level module (<code>require(\"ltf-serial\")</code>). Most users should use the high-level API above.</p>"},{"location":"LTF_LIBS/ltf.ssh/","title":"SSH (<code>ltf.ssh</code>)","text":"<p><code>ltf.ssh</code> provides SSH connectivity for tests, including:</p> <ul> <li>Creating SSH sessions (<code>ssh.new_session</code>)</li> <li>Executing remote commands (<code>session:new_exec_channel():exec(...)</code>)</li> <li>Interactive shell channels with PTY (<code>session:new_shell_channel(...)</code>)</li> <li>SFTP file transfer (<code>session:new_sftp_channel():send(...)</code>, <code>:receive(...)</code>)</li> <li>Access to the underlying low-level bindings (<code>ssh.low</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#getting-started","title":"Getting started","text":"<p><code>ssh</code> is exposed as a submodule of <code>ltf</code>:</p> <pre><code>local ltf = require(\"ltf\")\nlocal ssh = ltf.ssh\n</code></pre> <p>A typical workflow:</p> <ol> <li>Create a session (<code>ssh.new_session(...)</code>)</li> <li>Connect (<code>session:connect()</code>)</li> <li>Use exec/shell/sftp channels</li> <li>Close the session (<code>session:close()</code>)</li> </ol>"},{"location":"LTF_LIBS/ltf.ssh/#api-reference","title":"API reference","text":""},{"location":"LTF_LIBS/ltf.ssh/#creating-a-session","title":"Creating a session","text":""},{"location":"LTF_LIBS/ltf.ssh/#ltfsshnew_sessionparams","title":"<code>ltf.ssh.new_session(params)</code>","text":"<p>Creates a new SSH session object.</p> <p>Parameters:</p> <ul> <li> <p><code>params</code> (<code>ssh_create_session_params</code>):</p> </li> <li> <p><code>ip</code> (<code>string</code>, required): remote host IP/hostname</p> </li> <li><code>port</code> (<code>integer</code>, optional): SSH port (default: <code>22</code>)</li> <li><code>userpass</code> (<code>ssh_auth_method_userpass</code>, optional): authenticate using username+password</li> </ul> <p>Returns:</p> <ul> <li>(<code>ssh_session</code>)</li> </ul> <p>Note: right now the only supported auth method in this wrapper is <code>userpass</code>.</p> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal ssh = ltf.ssh\n\nltf.test({\n  name = \"SSH connect\",\n  body = function()\n    local session = ssh.new_session({\n      ip = \"192.168.1.10\",\n      userpass = { user = \"root\", password = \"toor\" },\n    })\n\n    ltf.defer(session.close, session)\n\n    session:connect()\n    ltf.log_info(\"Connected.\")\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.ssh/#ssh_session-methods","title":"<code>ssh_session</code> methods","text":""},{"location":"LTF_LIBS/ltf.ssh/#sessionconnect","title":"<code>session:connect()</code>","text":"<p>Connect to the remote host.</p>"},{"location":"LTF_LIBS/ltf.ssh/#sessiondisconnectdescription","title":"<code>session:disconnect(description?)</code>","text":"<p>Disconnect from the remote host (optionally with a description string).</p>"},{"location":"LTF_LIBS/ltf.ssh/#sessionclose","title":"<code>session:close()</code>","text":"<p>Disconnect (if needed) and close the session.</p>"},{"location":"LTF_LIBS/ltf.ssh/#channels-overview","title":"Channels overview","text":"<p>A session can create three \u201cchannel types\u201d:</p> <ul> <li>Exec channel for running a command and collecting stdout/stderr/exit code</li> <li>Shell channel for interactive shell-like I/O (PTY + <code>shell()</code>)</li> <li>SFTP channel for file transfer and remote file inspection</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#exec-channel","title":"Exec channel","text":""},{"location":"LTF_LIBS/ltf.ssh/#sessionnew_exec_channel-ssh_exec_channel","title":"<code>session:new_exec_channel() -&gt; ssh_exec_channel</code>","text":"<p>Creates an exec channel wrapper.</p>"},{"location":"LTF_LIBS/ltf.ssh/#exec_chanexecopts-ssh_channel_exec_result","title":"<code>exec_chan:exec(opts) -&gt; ssh_channel_exec_result</code>","text":"<p>Executes a command on the remote host and returns collected output.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>ssh_channel_exec_opts</code>):</p> </li> <li> <p><code>cmd</code> (<code>string</code>, required): command to execute</p> </li> <li><code>env</code> (<code>table&lt;string,string&gt;</code>, optional): environment variables</li> <li><code>read_chunk_size</code> (<code>integer</code>, optional): read chunk size (default: <code>64</code>)</li> </ul> <p>Returns:</p> <ul> <li> <p><code>ssh_channel_exec_result</code>:</p> </li> <li> <p><code>stdout</code> (<code>string</code>)</p> </li> <li><code>stderr</code> (<code>string</code>)</li> <li><code>exitcode</code> (<code>integer</code>)</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal ssh = ltf.ssh\n\nltf.test({\n  name = \"SSH exec\",\n  body = function()\n    local session = ssh.new_session({\n      ip = \"192.168.1.10\",\n      userpass = { user = \"root\", password = \"toor\" },\n    })\n    ltf.defer(session.close, session)\n\n    session:connect()\n\n    local ch = session:new_exec_channel()\n    ltf.defer(ch.close, ch)\n\n    local res = ch:exec({\n      cmd = \"uname -a\",\n      env = { LANG = \"C\" },\n    })\n\n    ltf.log_info(\"Exit:\", res.exitcode)\n    ltf.print(\"STDOUT:\", res.stdout)\n    ltf.print(\"STDERR:\", res.stderr)\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.ssh/#exec_chanclose","title":"<code>exec_chan:close()</code>","text":"<p>Closes the underlying SSH channel.</p>"},{"location":"LTF_LIBS/ltf.ssh/#shell-channel","title":"Shell channel","text":""},{"location":"LTF_LIBS/ltf.ssh/#sessionnew_shell_channelopts-ssh_shell_channel","title":"<code>session:new_shell_channel(opts?) -&gt; ssh_shell_channel</code>","text":"<p>Creates an interactive shell channel:</p> <ul> <li>Requests a PTY</li> <li>Switches to shell mode</li> </ul> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>ssh_shell_channel_opts</code>, optional):</p> </li> <li> <p><code>terminal</code> (<code>string</code>, optional): PTY terminal name (default: <code>\"xterm\"</code>)</p> </li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#shellwritestr","title":"<code>shell:write(str)</code>","text":"<p>Writes a string to the remote shell.</p>"},{"location":"LTF_LIBS/ltf.ssh/#shellreadopts-string","title":"<code>shell:read(opts?) -&gt; string</code>","text":"<p>Reads a chunk from the remote shell.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>ssh_channel_read_opts</code>, optional):</p> </li> <li> <p><code>stream</code> (<code>ssh_channel_stream</code>, optional): <code>\"stdout\"</code> or <code>\"stderr\"</code> (default: <code>\"stdout\"</code>)</p> </li> <li><code>chunk_size</code> (<code>integer</code>, optional): default <code>64</code></li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#shellread_untilopts-found-read","title":"<code>shell:read_until(opts) -&gt; (found, read)</code>","text":"<p>Reads until a fixed-string pattern appears (or timeout expires).</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>ssh_read_until_opts</code>):</p> </li> <li> <p><code>pattern</code> (<code>string</code>, optional): fixed pattern searched via <code>string.find(..., true)</code> (default: <code>\"\\n\"</code>)</p> </li> <li><code>timeout</code> (<code>integer</code>, optional): milliseconds (default: <code>200</code>)</li> <li><code>read_opts</code> (<code>ssh_channel_read_opts</code>, optional)</li> </ul> <p>Returns:</p> <ul> <li><code>found</code> (<code>boolean</code>): <code>true</code> if pattern appeared within timeout</li> <li><code>read</code> (<code>string</code>): everything read (always returned)</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal ssh = ltf.ssh\n\nltf.test({\n  name = \"SSH shell read_until\",\n  body = function()\n    local session = ssh.new_session({\n      ip = \"192.168.1.10\",\n      userpass = { user = \"root\", password = \"toor\" },\n    })\n    ltf.defer(session.close, session)\n\n    session:connect()\n\n    local sh = session:new_shell_channel({ terminal = \"xterm\" })\n    ltf.defer(sh.close, sh)\n\n    sh:write(\"echo READY\\n\")\n\n    local ok, out = sh:read_until({\n      pattern = \"READY\",\n      timeout = 2000,\n    })\n\n    if not ok then\n      ltf.log_error(\"Did not see READY. Output:\", out)\n    else\n      ltf.log_info(\"Shell output:\", out)\n    end\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.ssh/#shellclose","title":"<code>shell:close()</code>","text":"<p>Closes the underlying SSH channel.</p>"},{"location":"LTF_LIBS/ltf.ssh/#sftp","title":"SFTP","text":""},{"location":"LTF_LIBS/ltf.ssh/#sessionnew_sftp_channel-sftp_channel","title":"<code>session:new_sftp_channel() -&gt; sftp_channel</code>","text":"<p>Creates an SFTP channel wrapper.</p>"},{"location":"LTF_LIBS/ltf.ssh/#sftpsendopts","title":"<code>sftp:send(opts)</code>","text":"<p>Uploads a local file to the remote host.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>sftp_file_transfer_opts</code>):</p> </li> <li> <p><code>local_file</code> (<code>string</code>, required)</p> </li> <li><code>remote_file</code> (<code>string</code>, required)</li> <li><code>resolve_symlinks</code> (<code>boolean</code>, optional): whether to follow symlinks (default: <code>true</code>)</li> <li><code>mode</code> (<code>sftp_channel_send_flag</code>, optional): <code>\"create\"</code> (default) or <code>\"overwrite\"</code></li> <li><code>file_permissions</code> (<code>integer</code>, optional): remote file permissions (default: <code>420</code>)</li> <li><code>chunk_size</code> (<code>integer</code>, optional): write chunk size (default: <code>1024</code>)</li> </ul> <p>Behavior notes:</p> <ul> <li>Directories are not supported (will error).</li> <li>If <code>mode = \"create\"</code> and the remote file already exists, <code>send()</code> errors.</li> <li>If local file size is 0, <code>send()</code> errors.</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal ssh = ltf.ssh\n\nltf.test({\n  name = \"SFTP upload\",\n  body = function()\n    local session = ssh.new_session({\n      ip = \"192.168.1.10\",\n      userpass = { user = \"root\", password = \"toor\" },\n    })\n    ltf.defer(session.close, session)\n\n    session:connect()\n\n    local sftp = session:new_sftp_channel()\n    ltf.defer(sftp.close, sftp)\n\n    sftp:send({\n      local_file = \"./artifacts/report.txt\",\n      remote_file = \"/tmp/report.txt\",\n      mode = \"overwrite\",\n      chunk_size = 2048,\n    })\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.ssh/#sftpreceiveopts","title":"<code>sftp:receive(opts)</code>","text":"<p>Downloads a remote file to a local path.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>sftp_file_transfer_opts</code>):</p> </li> <li> <p><code>remote_file</code> (<code>string</code>, required)</p> </li> <li><code>local_file</code> (<code>string</code>, required)</li> <li><code>chunk_size</code> (<code>integer</code>, optional): read chunk size (default: <code>1024</code>)</li> </ul> <p>Example:</p> <pre><code>sftp:receive({\n  remote_file = \"/tmp/report.txt\",\n  local_file = \"./downloaded_report.txt\",\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.ssh/#sftpfile_infopath-file_info","title":"<code>sftp:file_info(path) -&gt; file_info?</code>","text":"<p>Returns remote <code>file_info</code> for <code>path</code>, or <code>nil</code> if it doesn\u2019t exist (as provided by the low-level binding).</p>"},{"location":"LTF_LIBS/ltf.ssh/#sftpclose","title":"<code>sftp:close()</code>","text":"<p>Shuts down the SFTP channel (<code>shutdown()</code>).</p>"},{"location":"LTF_LIBS/ltf.ssh/#low-level-channel-type-ssh_channel","title":"Low-level channel type (<code>ssh_channel</code>)","text":"<p>Most users won\u2019t need to use <code>ssh_channel</code> directly, but it exists underneath the wrappers:</p> <ul> <li><code>ltf.ssh.channel.open_channel(session) -&gt; ssh_channel</code></li> </ul> <p>The low-level channel supports methods like:</p> <ul> <li><code>exec(cmd)</code>, <code>shell()</code>, <code>request_pty(term)</code></li> <li><code>read(chunk_size)</code>, <code>read_stderr(chunk_size)</code>, <code>write(str)</code></li> <li><code>flush()</code>, <code>flush_stderr()</code></li> <li><code>setenv(var, value)</code></li> <li><code>send_eof()</code>, <code>eof()</code>, <code>wait_eof()</code></li> <li><code>get_exit_status()</code></li> <li><code>close()</code></li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#data-structures-types","title":"Data structures &amp; types","text":""},{"location":"LTF_LIBS/ltf.ssh/#ssh_auth_method_userpass","title":"<code>ssh_auth_method_userpass</code>","text":"<ul> <li><code>user</code> (<code>string</code>)</li> <li><code>password</code> (<code>string</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#ssh_create_session_params","title":"<code>ssh_create_session_params</code>","text":"<ul> <li><code>ip</code> (<code>string</code>)</li> <li><code>port</code> (<code>integer?</code>)</li> <li><code>userpass</code> (<code>ssh_auth_method_userpass?</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#ssh_channel_exec_opts","title":"<code>ssh_channel_exec_opts</code>","text":"<ul> <li><code>cmd</code> (<code>string</code>)</li> <li><code>env</code> (<code>table&lt;string,string&gt;?</code>)</li> <li><code>read_chunk_size</code> (<code>integer?</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#ssh_channel_exec_result","title":"<code>ssh_channel_exec_result</code>","text":"<ul> <li><code>stdout</code> (<code>string</code>)</li> <li><code>stderr</code> (<code>string</code>)</li> <li><code>exitcode</code> (<code>integer</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#ssh_channel_stream","title":"<code>ssh_channel_stream</code>","text":"<ul> <li><code>\"stdout\"</code></li> <li><code>\"stderr\"</code></li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#ssh_channel_read_opts","title":"<code>ssh_channel_read_opts</code>","text":"<ul> <li><code>chunk_size</code> (<code>integer?</code>, default: <code>64</code>)</li> <li><code>stream</code> (<code>ssh_channel_stream?</code>, default: <code>\"stdout\"</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#ssh_shell_channel_opts","title":"<code>ssh_shell_channel_opts</code>","text":"<ul> <li><code>terminal</code> (<code>string?</code>, default: <code>\"xterm\"</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#ssh_read_until_opts","title":"<code>ssh_read_until_opts</code>","text":"<ul> <li><code>pattern</code> (<code>string?</code>, default: <code>\"\\n\"</code>)</li> <li><code>timeout</code> (<code>integer?</code>, default: <code>200</code>)</li> <li><code>read_opts</code> (<code>ssh_channel_read_opts?</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.ssh/#sftp_channel_send_flag","title":"<code>sftp_channel_send_flag</code>","text":"<ul> <li><code>\"create\"</code>: fail if remote file already exists</li> <li><code>\"overwrite\"</code>: overwrite remote file if it exists</li> </ul>"},{"location":"LTF_LIBS/ltf.util/","title":"Utils","text":"<pre><code># File Utilities (`ltf.util`)\n\n`ltf.util` contains small helpers that don\u2019t belong to a specific subsystem. Right now it provides:\n\n* `file_info(path)` \u2014 inspect a filesystem path\n* `resolve_symlink(path)` \u2014 resolve a symlink target (with clear error/`nil` behavior)\n\n## Getting started\n\n`util` is exposed as a submodule of `ltf`:\n\n```lua\nlocal ltf = require(\"ltf\")\nlocal util = ltf.util\n</code></pre>"},{"location":"LTF_LIBS/ltf.util/#api-reference","title":"API reference","text":""},{"location":"LTF_LIBS/ltf.util/#ltfutilfile_infopath-file_info","title":"<code>ltf.util.file_info(path) -&gt; file_info?</code>","text":"<p>Returns information about a filesystem path.</p> <p>Parameters:</p> <ul> <li><code>path</code> (<code>string</code>): file/directory/symlink path (relative or absolute)</li> </ul> <p>Returns:</p> <ul> <li><code>file_info</code> if the path exists</li> <li><code>nil</code> if the path does not exist</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal util = ltf.util\n\nltf.test({\n  name = \"Inspect a path\",\n  body = function()\n    local info = util.file_info(\"./build/output.bin\")\n    if not info then\n      ltf.log_error(\"Path does not exist\")\n      return\n    end\n\n    ltf.log_info(\"Path:\", info.path)\n    ltf.log_info(\"Type:\", info.type)\n    ltf.log_info(\"Size:\", info.size)\n    ltf.log_info(\"Permissions:\", info.permissions)\n\n    if info.type == \"symlink\" then\n      local resolved = util.resolve_symlink(info.path)\n      if resolved then\n        ltf.log_info(\"Resolved to:\", resolved)\n      else\n        ltf.log_warning(\"Symlink is dangling (target does not exist)\")\n      end\n    end\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.util/#ltfutilresolve_symlinkpath-string","title":"<code>ltf.util.resolve_symlink(path) -&gt; string?</code>","text":"<p>Resolves a symlink target.</p> <p>Behavior:</p> <ul> <li>Throws an error if the symlink path does not exist (or is not a symlink, depending on implementation).</li> <li>Returns <code>nil</code> if the symlink exists but is dangling (target does not exist).</li> <li>Returns <code>string</code> (resolved path) if the link resolves to an existing target.</li> </ul> <p>Parameters:</p> <ul> <li><code>path</code> (<code>string</code>): path to the symlink (relative or absolute)</li> </ul> <p>Returns:</p> <ul> <li><code>string?</code> resolved path, or <code>nil</code> if dangling</li> </ul> <p>Example:</p> <pre><code>local ltf = require(\"ltf\")\nlocal util = ltf.util\n\nltf.test({\n  name = \"Resolve symlink\",\n  body = function()\n    local resolved = util.resolve_symlink(\"./latest.log\")\n    if resolved == nil then\n      ltf.log_warning(\"Symlink exists, but target is missing (dangling).\")\n      return\n    end\n\n    ltf.log_info(\"Symlink points to:\", resolved)\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.util/#data-structures-types","title":"Data structures &amp; types","text":""},{"location":"LTF_LIBS/ltf.util/#file_info-table","title":"<code>file_info</code> (table)","text":"<p>Returned by <code>ltf.util.file_info()</code>.</p> Field Type Description <code>type</code> <code>file_info_type</code> The type of the path. <code>path</code> <code>string</code> Absolute path to the file/directory/symlink. <code>size</code> <code>integer</code> Size in bytes (for directories this may be implementation-defined). For symlinks, this is the symlink size. <code>permissions</code> <code>integer</code> File permissions (platform-dependent numeric mode)."},{"location":"LTF_LIBS/ltf.util/#file_info_type","title":"<code>file_info_type</code>","text":"<p>Accepted values:</p> <ul> <li><code>\"file\"</code></li> <li><code>\"directory\"</code></li> <li><code>\"symlink\"</code></li> </ul>"},{"location":"LTF_LIBS/ltf.util/#low-level-access","title":"Low-level access","text":""},{"location":"LTF_LIBS/ltf.util/#ltfutillow","title":"<code>ltf.util.low</code>","text":"<p>If exposed by your build, <code>ltf.util.low</code> provides the underlying low-level module (<code>require(\"ltf-util\")</code>). Most users should use the high-level helpers above.</p> <pre><code></code></pre>"},{"location":"LTF_LIBS/ltf.webdriver/","title":"Web Browser Automation (<code>ltf.webdriver</code>)","text":"<p><code>ltf.webdriver</code> provides a W3C WebDriver client for automating browsers through a running WebDriver server (for example <code>chromedriver</code>, <code>geckodriver</code>). It helps you:</p> <ul> <li>spawn a driver process (<code>webdriver.spawn_webdriver</code>)</li> <li>start a browser session (<code>webdriver.new_session</code>)</li> <li>drive the browser via a <code>session</code> object (navigation, element actions, JS execution, screenshots, etc.)</li> <li>close the session (<code>session:close()</code>)</li> </ul> <p>This module is a client. You must have a WebDriver server binary installed (and typically available in your PATH), or provide an explicit executable path.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#getting-started","title":"Getting started","text":"<p><code>webdriver</code> is exposed as a submodule of <code>ltf</code>:</p> <pre><code>local ltf = require(\"ltf\")\nlocal webdriver = ltf.webdriver\n````\n\nTypical flow:\n\n1. Spawn a WebDriver server process.\n2. Start a session (opens a browser).\n3. Interact with pages/elements.\n4. Close the session and kill the driver.\n\n---\n\n## Driver management\n\n### `ltf.webdriver.spawn_webdriver(opts)`\n\nSpawns a WebDriver server process listening on the given port.\n\n**Parameters:**\n\n* `opts` (`wd_spawn_opts`):\n\n  * `port` (`integer`, required): port for the driver to listen on\n  * `webdriver` (`string|webdriver`, optional): executable path/name. Default: `\"chromedriver\"`.\n  * `extraflags` (`string[]`, optional): additional CLI flags passed to the driver\n\n**Returns:**\n\n* (`proc_handle`): process handle (from `ltf.proc.spawn()`)\n\n**Notes:**\n\n* `spawn_webdriver` always injects the port flag by appending `--port=&lt;port&gt;` to the driver arguments.\n  Avoid passing your own `--port=...` in `extraflags` unless you want duplicates.\n\n**Example:**\n\n```lua\nlocal ltf = require(\"ltf\")\nlocal webdriver = ltf.webdriver\n\nlocal driver = webdriver.spawn_webdriver({\n  webdriver = \"chromedriver\",\n  port = 9515,\n})\n\n-- Always clean up the driver process\nltf.defer(driver.kill, driver)\n</code></pre>"},{"location":"LTF_LIBS/ltf.webdriver/#session-management","title":"Session management","text":""},{"location":"LTF_LIBS/ltf.webdriver/#ltfwebdrivernew_sessionopts","title":"<code>ltf.webdriver.new_session(opts)</code>","text":"<p>Connects to the WebDriver server and starts a new browser session (which opens a browser window).</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>wd_session_opts</code>):</p> </li> <li> <p><code>port</code> (<code>integer</code>, required): WebDriver server port</p> </li> <li><code>url</code> (<code>string</code>, optional): server URL. Default: <code>\"http://localhost\"</code>.</li> <li><code>request_object</code> (<code>table</code>, optional): full JSON body for the <code>POST /session</code> request (advanced)</li> <li><code>headless</code> (<code>boolean</code>, optional): create session in headless mode. Default: <code>false</code>.</li> <li><code>headless_implementation</code> (<code>webdriver</code>, optional): which driver\u2019s default headless caps to apply.     Default: <code>\"chromedriver\"</code>. Supported defaults: <code>\"chromedriver\"</code>, <code>\"operadriver\"</code>, <code>\"geckodriver\"</code>, <code>\"msedgedriver\"</code>.</li> </ul> <p>Returns:</p> <ul> <li>(<code>wd_session</code>): session object (methods below)</li> </ul> <p>Notes:</p> <ul> <li>If <code>opts.request_object</code> is provided, it is used as the base JSON request body, then normalized into W3C <code>capabilities</code> shape.</li> <li>For older drivers, <code>desiredCapabilities</code> (if provided in <code>request_object</code>) is preserved.</li> <li> <p>If <code>opts.headless = true</code>, the module injects common headless flags into capabilities for supported implementations:</p> </li> <li> <p>Chrome/Opera: adds <code>--headless=new</code> and <code>--disable-gpu</code> into <code>goog:chromeOptions.args</code></p> </li> <li>Firefox: adds <code>-headless</code> into <code>moz:firefoxOptions.args</code></li> <li>Edge: adds <code>--headless=new</code> and <code>--disable-gpu</code> into <code>ms:edgeOptions.args</code></li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionclose","title":"<code>session:close()</code>","text":"<p>Ends the session (closes the browser).</p> <p>Common pattern:</p> <pre><code>local session = webdriver.new_session({ port = 9515 })\nltf.defer(session.close, session)\n</code></pre>"},{"location":"LTF_LIBS/ltf.webdriver/#the-session-object","title":"The <code>session</code> object","text":"<p>The <code>session</code> returned by <code>webdriver.new_session()</code> is your handle to a browser instance.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#fields","title":"Fields","text":"<ul> <li><code>base_url</code> (<code>string</code>)</li> <li><code>port</code> (<code>integer</code>)</li> <li><code>id</code> (<code>string</code>): session id</li> <li><code>headless</code> (<code>boolean</code>): true if created with <code>opts.headless = true</code></li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#error-behavior","title":"Error behavior","text":"<p>Some helpers surface WebDriver errors as Lua errors (notably: <code>new_session</code>, <code>click</code>, <code>send_keys</code>, <code>resize_window</code>, <code>wait_until_visible</code>). If you want to handle failures without aborting the test, wrap calls in <code>pcall</code>.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#browser-navigation-session-methods","title":"Browser navigation (session methods)","text":""},{"location":"LTF_LIBS/ltf.webdriver/#sessionopen_urlurl","title":"<code>session:open_url(url)</code>","text":"<p>Navigates to <code>url</code>.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionget_current_url-string","title":"<code>session:get_current_url() -&gt; string</code>","text":"<p>Returns the current page URL.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionget_title-string","title":"<code>session:get_title() -&gt; string</code>","text":"<p>Returns the current page title.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessiongo_back","title":"<code>session:go_back()</code>","text":"<p>Back in history.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessiongo_forward","title":"<code>session:go_forward()</code>","text":"<p>Forward in history.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionrefresh","title":"<code>session:refresh()</code>","text":"<p>Reloads the page.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionresize_windowopts","title":"<code>session:resize_window(opts?)</code>","text":"<p>Resizes the browser window.</p> <ul> <li>If <code>opts</code> is <code>nil</code>: maximizes the window.</li> <li>If provided: <code>{ width = number, height = number }</code></li> </ul> <p>If the driver returns an error response, <code>resize_window</code> throws a Lua error.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#finding-and-interacting-with-elements","title":"Finding and interacting with elements","text":""},{"location":"LTF_LIBS/ltf.webdriver/#sessionfind_elementopts-string","title":"<code>session:find_element(opts) -&gt; string</code>","text":"<p>Finds the first matching element.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>wd_session_find_elements_opts</code>):</p> </li> <li> <p><code>using</code> (<code>string</code>): <code>\"css selector\"</code>, <code>\"xpath\"</code>, etc.</p> </li> <li><code>value</code> (<code>string</code>): selector value</li> </ul> <p>Returns:</p> <ul> <li>(<code>string</code>): <code>element_id</code></li> </ul> <p>Notes:</p> <ul> <li>Element IDs are extracted using the W3C element key   <code>\"element-6066-11e4-a52e-4f735466cecf\"</code> and fall back to legacy <code>\"ELEMENT\"</code> if needed.</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionfind_elementsopts-string","title":"<code>session:find_elements(opts) -&gt; string[]</code>","text":"<p>Finds all matching elements (returns array of <code>element_id</code>).</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionclickelement_id","title":"<code>session:click(element_id)</code>","text":"<p>Clicks the element.</p> <p>Throws a Lua error if the driver returns an error response.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionget_textelement_id-string","title":"<code>session:get_text(element_id) -&gt; string</code>","text":"<p>Gets visible text for the element.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionsend_keysopts","title":"<code>session:send_keys(opts)</code>","text":"<p>Sends keystrokes to an element.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>wd_session_send_keys_opts</code>):</p> </li> <li> <p><code>element_id</code> (<code>string</code>)</p> </li> <li><code>text</code> (<code>string</code>)</li> </ul> <p>Notes:</p> <ul> <li>Uses W3C <code>text</code> and includes a legacy <code>value</code> array of characters for compatibility.</li> </ul> <p>Throws a Lua error if the driver returns an error response.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessioninput_textopts","title":"<code>session:input_text(opts)</code>","text":"<p>Convenience helper: clears the element (by default) and then sends keys.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>wd_session_input_text_opts</code>):</p> </li> <li> <p><code>element_id</code> (<code>string</code>)</p> </li> <li><code>text</code> (<code>string</code>)</li> <li><code>clear_first</code> (<code>boolean</code>, optional, default: <code>true</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionwait_until_visibleopts-string","title":"<code>session:wait_until_visible(opts) -&gt; string</code>","text":"<p>Polls until an element is visible (or times out). Returns the element id.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>wd_session_wait_until_visible_opts</code>):</p> </li> <li> <p><code>using</code> (<code>string</code>)</p> </li> <li><code>value</code> (<code>string</code>)</li> <li><code>timeout</code> (<code>integer</code>, optional, default: <code>5000</code>)</li> </ul> <p>Behavior:</p> <ul> <li>Repeatedly calls <code>find_element</code> and then polls the element <code>.../displayed</code> endpoint until it becomes visible.</li> <li>Throws a Lua error on timeout.</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionscroll_into_viewelement_id","title":"<code>session:scroll_into_view(element_id)</code>","text":"<p>Scrolls an element into view via JavaScript <code>scrollIntoView</code>.</p>"},{"location":"LTF_LIBS/ltf.webdriver/#sessiondrag_and_dropopts","title":"<code>session:drag_and_drop(opts)</code>","text":"<p>Drag-and-drop using W3C Actions with a single mouse pointer device.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>wd_session_drag_and_drop_opts</code>):</p> </li> <li> <p><code>source_id</code> (<code>string</code>): element to grab</p> </li> <li><code>target_id</code> (<code>string</code>): element to drop on</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#advanced-usage","title":"Advanced usage","text":""},{"location":"LTF_LIBS/ltf.webdriver/#sessionexecuteopts-table","title":"<code>session:execute(opts) -&gt; table</code>","text":"<p>Executes synchronous JS (<code>POST /execute/sync</code>).</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>wd_session_execute_opts</code>):</p> </li> <li> <p><code>script</code> (<code>string</code>): JS source</p> </li> <li><code>args</code> (<code>table</code>, optional): array of arguments</li> </ul> <p>Notes:</p> <ul> <li>To pass an element as an argument, provide a W3C element reference object:   <code>{ [\"element-6066-11e4-a52e-4f735466cecf\"] = element_id }</code></li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#sessionscreenshot-string","title":"<code>session:screenshot() -&gt; string?</code>","text":"<p>Returns a full-page screenshot as base64 PNG (driver-dependent).</p> <p>Returns:</p> <ul> <li>(<code>string?</code>): base64 PNG on success, or <code>nil</code> if not available.</li> </ul> <p>Note:</p> <ul> <li>Most drivers return a base64 string. If the driver returns an unusual error shape, you may get a non-string <code>value</code>.   Use <code>pcall</code> if you want to handle driver quirks gracefully.</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#sessioncmdopts-table","title":"<code>session:cmd(opts) -&gt; table</code>","text":"<p>Low-level helper to call arbitrary WebDriver session endpoints.</p> <p>Parameters:</p> <ul> <li> <p><code>opts</code> (<code>wd_session_cmd_opts</code>):</p> </li> <li> <p><code>method</code> (<code>api_method</code>): <code>\"GET\"|\"POST\"|\"PUT\"|\"DELETE\"</code> (case-insensitive)</p> </li> <li><code>endpoint</code> (<code>string</code>): endpoint suffix after <code>/session/&lt;id&gt;/</code> (examples: <code>\"url\"</code>, <code>\"element\"</code>, <code>\"actions\"</code>, <code>\"execute/sync\"</code>)</li> <li><code>payload</code> (<code>table</code>, optional): payload (used for POST/PUT; ignored for GET/DELETE)</li> </ul> <p>Returns:</p> <ul> <li>(<code>table</code>): decoded JSON response (typically with a <code>value</code> field)</li> </ul> <p>Important:</p> <ul> <li><code>endpoint</code> should be a suffix like <code>\"url\"</code> \u2014 do not include <code>/session/&lt;id&gt;/</code> in it.</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#full-example","title":"Full example","text":"<pre><code>local ltf = require(\"ltf\")\nlocal webdriver = ltf.webdriver\n\nltf.test({\n  name = \"Google Search with WebDriver\",\n  tags = { \"e2e\", \"smoke\" },\n  body = function()\n    -- 1) Spawn driver\n    ltf.log_info(\"Spawning chromedriver on port 9515...\")\n    local driver = webdriver.spawn_webdriver({\n      webdriver = \"chromedriver\",\n      port = 9515,\n    })\n    ltf.defer(driver.kill, driver)\n\n    -- Give the driver a moment to start\n    ltf.sleep(2000)\n\n    -- 2) Start session\n    ltf.log_info(\"Starting new browser session...\")\n    local session = webdriver.new_session({\n      port = 9515,\n      headless = false, -- set true for headless mode\n    })\n    ltf.defer(session.close, session)\n\n    -- 3) Interact\n    session:open_url(\"https://www.google.com\")\n    ltf.log_info(\"Opened google.com. Title:\", session:get_title())\n\n    local search_box = session:wait_until_visible({\n      using = \"css selector\",\n      value = \"textarea[name='q']\",\n      timeout = 5000,\n    })\n\n    session:input_text({\n      element_id = search_box,\n      text = \"Test Automation Framework\",\n      clear_first = true,\n    })\n\n    -- Most stable: submit with Enter (instead of chasing dynamic button selectors)\n    session:send_keys({\n      element_id = search_box,\n      text = \"\\n\",\n    })\n\n    ltf.sleep(3000)\n\n    local new_title = session:get_title()\n    ltf.log_info(\"Results page title:\", new_title)\n    if not new_title:find(\"Test Automation Framework\") then\n      ltf.log_error(\"Page title did not update as expected.\")\n    end\n  end,\n})\n</code></pre>"},{"location":"LTF_LIBS/ltf.webdriver/#data-structures-types","title":"Data structures &amp; types","text":""},{"location":"LTF_LIBS/ltf.webdriver/#wd_spawn_opts-table","title":"<code>wd_spawn_opts</code> (table)","text":"<ul> <li><code>webdriver</code> (<code>string|webdriver</code>, optional): executable path/name. Default: <code>\"chromedriver\"</code></li> <li><code>port</code> (<code>integer</code>, required)</li> <li><code>extraflags</code> (<code>string[]</code>, optional): extra CLI flags passed to the driver (port flag is appended automatically)</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#wd_session_opts-table","title":"<code>wd_session_opts</code> (table)","text":"<ul> <li><code>port</code> (<code>integer</code>, required)</li> <li><code>url</code> (<code>string</code>, optional): default <code>\"http://localhost\"</code></li> <li><code>request_object</code> (<code>table</code>, optional): raw <code>POST /session</code> request body</li> <li><code>headless</code> (<code>boolean</code>, optional): default <code>false</code></li> <li><code>headless_implementation</code> (<code>webdriver</code>, optional): default <code>\"chromedriver\"</code>.   Supported defaults: <code>\"chromedriver\"</code>, <code>\"operadriver\"</code>, <code>\"geckodriver\"</code>, <code>\"msedgedriver\"</code>.</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#wd_session_cmd_opts-table","title":"<code>wd_session_cmd_opts</code> (table)","text":"<ul> <li><code>method</code> (<code>api_method</code>): <code>\"GET\"|\"POST\"|\"PUT\"|\"DELETE\"</code> (case-insensitive)</li> <li><code>endpoint</code> (<code>string</code>): endpoint suffix after <code>/session/&lt;id&gt;/</code></li> <li><code>payload</code> (<code>table</code>, optional): payload for POST/PUT</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#wd_session_find_elements_opts-table","title":"<code>wd_session_find_elements_opts</code> (table)","text":"<ul> <li><code>using</code> (<code>string</code>): <code>\"css selector\"</code>, <code>\"xpath\"</code>, etc.</li> <li><code>value</code> (<code>string</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#wd_session_send_keys_opts-table","title":"<code>wd_session_send_keys_opts</code> (table)","text":"<ul> <li><code>element_id</code> (<code>string</code>)</li> <li><code>text</code> (<code>string</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#wd_session_input_text_opts-table","title":"<code>wd_session_input_text_opts</code> (table)","text":"<ul> <li><code>element_id</code> (<code>string</code>)</li> <li><code>text</code> (<code>string</code>)</li> <li><code>clear_first</code> (<code>boolean</code>, optional, default: <code>true</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#wd_session_wait_until_visible_opts-table","title":"<code>wd_session_wait_until_visible_opts</code> (table)","text":"<ul> <li><code>using</code> (<code>string</code>)</li> <li><code>value</code> (<code>string</code>)</li> <li><code>timeout</code> (<code>integer</code>, optional, default: <code>5000</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#wd_session_drag_and_drop_opts-table","title":"<code>wd_session_drag_and_drop_opts</code> (table)","text":"<ul> <li><code>source_id</code> (<code>string</code>)</li> <li><code>target_id</code> (<code>string</code>)</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#wd_session_execute_opts-table","title":"<code>wd_session_execute_opts</code> (table)","text":"<ul> <li><code>script</code> (<code>string</code>)</li> <li><code>args</code> (<code>table</code>, optional)</li> </ul>"},{"location":"LTF_LIBS/ltf.webdriver/#low-level-notes","title":"Low-level notes","text":"<ul> <li>Element IDs are extracted using the W3C element key:   <code>\"element-6066-11e4-a52e-4f735466cecf\"</code>, with fallback to legacy <code>\"ELEMENT\"</code>.</li> <li>Driver errors are surfaced as Lua errors in helpers like <code>click</code>, <code>send_keys</code>, <code>resize_window</code>, <code>wait_until_visible</code>, and session creation.</li> <li><code>session:cmd()</code> is the escape hatch for anything not wrapped by higher-level helpers.</li> </ul>"},{"location":"TESTS/LOGGING/","title":"LTF Logging","text":"<p>LTF provides a comprehensive logging system that automatically records the details of every test run. These logs are essential for debugging failures, reviewing test output, and archiving test results.</p>"},{"location":"TESTS/LOGGING/#log-file-generation","title":"Log File Generation","text":"<p>LTF generates log files automatically in the <code>your_project/logs/</code> directory after every test run.</p> <ul> <li>To disable log file creation for a specific run, use the <code>--no-logs</code> or <code>-n</code> command-line option:     <code>bash     ltf test --no-logs</code></li> <li>For multi-target projects, logs are organized into subdirectories for each target: <code>your_project/logs/your_target/</code>.</li> </ul> <p>LTF produces two types of log files for each run.</p>"},{"location":"TESTS/LOGGING/#output-log","title":"\ud83d\udcdd Output Log","text":"<p>This file contains the human-readable console output from the test run, exactly as it appears in the LTF Terminal UI (TUI). It's perfect for a quick review of what happened during the test.</p> <ul> <li>Filename: <code>test_run_[DATE]-[TIME]_output.log</code></li> <li>Latest Symlink: A convenience symlink named <code>test_run_latest_output.log</code> is always created, pointing to the log file from the most recent test run.</li> </ul>"},{"location":"TESTS/LOGGING/#raw-log-json","title":"Raw Log (JSON)","text":"<p>This file is a machine-readable JSON document containing a complete, structured record of the entire test run. It includes every log message regardless of level, test timings, statuses, and other metadata. It is ideal for programmatic analysis, reporting, or integration with other tools.</p> <ul> <li>Filename: <code>test_run_[DATE]-[TIME]_raw.json</code></li> <li>Latest Symlink: A symlink named <code>test_run_latest_raw.json</code> always points to the latest raw log.</li> <li>Schema: The schema for the raw log format can be found here.</li> </ul>"},{"location":"TESTS/LOGGING/#whats-inside-_rawjson","title":"What\u2019s inside <code>*_raw.json</code>","text":"<p>A raw log file is a single JSON object with:</p> <ul> <li>Run metadata: project name, LTF version, OS, timestamps, selected target, selected tags, and resolved variables.</li> <li>All discovered/selected tests (in execution order), each with:</li> <li>timestamps and final status</li> <li>tags</li> <li>complete output captured during the test</li> <li>structured failure reasons</li> <li>teardown output/errors (from <code>ltf.defer</code>)</li> <li>keyword/step timeline (nested \u201ccall stack\u201d-like structure)</li> </ul> <p>This makes <code>*_raw.json</code> a good source of truth for: * building custom HTML reports * CI summaries and dashboards * \u201cwhat changed?\u201d comparisons between runs * post-processing output into JUnit, Allure, etc.</p>"},{"location":"TESTS/LOGGING/#top-level-fields-overview","title":"Top-level fields (overview)","text":"<p>At the top level you\u2019ll usually see:</p> <ul> <li><code>project_name</code> \u2014 project directory name</li> <li><code>ltf_version</code> \u2014 LTF build version string</li> <li><code>os</code>, <code>os_version</code> \u2014 runtime platform information</li> <li><code>started</code>, <code>finished</code> \u2014 timestamps for the overall run</li> <li><code>target</code> \u2014 selected target (for multi-target) or project name</li> <li><code>variables</code> \u2014 resolved variables for this run (after CLI/scenario overrides)</li> <li><code>tags</code> \u2014 tags that filtered this run (if any)</li> <li><code>tests</code> \u2014 array of per-test entries</li> <li><code>total_amount</code>, <code>passed_amount</code>, <code>failed_amount</code>, <code>finished_amount</code> \u2014 summary counters</li> </ul> <p>Timestamp format: LTF timestamps use a compact string form like <code>MM.DD.YY-HH:MM:SS</code> (example: <code>12.25.25-00:29:10</code>). This is documented and validated in the JSON schema.</p>"},{"location":"TESTS/LOGGING/#per-test-entries","title":"Per-test entries","text":"<p>Each item in <code>tests[]</code> contains:</p> <ul> <li><code>name</code> \u2014 test name (unique identifier)</li> <li><code>started</code>, <code>finished</code></li> <li><code>status</code> \u2014 <code>\"PASSED\"</code> / <code>\"FAILED\"</code></li> <li><code>tags</code> \u2014 tags attached to the test</li> <li><code>output[]</code> \u2014 all log lines produced during the test body</li> <li><code>failure_reasons[]</code> \u2014 log entries that represent the failure reason(s)</li> <li><code>teardown_output[]</code> / <code>teardown_errors[]</code> \u2014 output/errors produced during deferred teardown</li> <li><code>keywords[]</code> \u2014 nested keyword timeline (steps)</li> </ul>"},{"location":"TESTS/LOGGING/#output-failure_reasons-teardown_","title":"<code>output[]</code> / <code>failure_reasons[]</code> / <code>teardown_*[]</code>","text":"<p>These arrays all share the same entry structure:</p> <ul> <li><code>file</code> \u2014 source file path where the message was emitted</li> <li><code>line</code> \u2014 line number</li> <li><code>date_time</code> \u2014 timestamp</li> <li><code>level</code> \u2014 <code>\"CRITICAL\"|\"ERROR\"|\"WARNING\"|\"INFO\"|\"DEBUG\"|\"TRACE\"</code></li> <li><code>msg</code> \u2014 message string</li> </ul> <p>Because the raw log captures all levels, it\u2019s normal for <code>*_raw.json</code> to contain more detail than the TUI/output log at lower verbosity levels.</p>"},{"location":"TESTS/LOGGING/#keywords-step-timeline","title":"<code>keywords[]</code> (step timeline)","text":"<p><code>keywords</code> is a structured timeline that represents nested \u201csteps\u201d inside a test.</p> <p>Each keyword contains:</p> <ul> <li><code>name</code></li> <li><code>started</code>, <code>finished</code></li> <li><code>file</code>, <code>line</code> (source location of the keyword)</li> <li><code>children[]</code> (nested keywords)</li> </ul> <p>This is useful for: * measuring step durations * building expandable timelines in reports * debugging \u201cwhere did the time go?\u201d inside long tests</p>"},{"location":"TESTS/LOGGING/#using-the-schema","title":"Using the schema","text":"<p>The raw log schema exists for tooling and integration. It helps you:</p> <ul> <li>validate log files in CI (catch format regressions)</li> <li>generate typed models (TypeScript/Python/Go, etc.)</li> <li>build parsers without guessing field names</li> </ul> <p>Example validation (using <code>ajv</code>):</p> <pre><code>ajv validate -s docs/raw_log_json_schema.json -d logs/test_run_latest_raw.json\n````\n\n&gt; Note: the schema is intentionally strict (`additionalProperties: false`) so that accidental format changes are detected early.\n\n---\n\n## \ud83d\udcf6 Log Levels\n\nLTF supports six hierarchical log levels, allowing you to control the verbosity of the output in the TUI and the [Output Log](#-output-log).\n\nThe levels, from most to least severe, are:\n\n* `critical`\n* `error`\n* `warning`\n* `info` (Default)\n* `debug`\n* `trace`\n\nYou can set the minimum log level for a run using the `--log-level` (or `-l`) option. Only messages of the specified level or higher will be displayed.\n\n```bash\n# Show only warnings, errors, and critical messages\nltf test --log-level warning\n\n# Or using the short-form\nltf test -l w\n</code></pre> <p>Important: Changing the log level only affects the TUI and the <code>output.log</code> file. The <code>raw.json</code> log always contains all messages from all levels, making it a complete record for debugging.</p> <p>By default, LTF runs with the <code>info</code> log level. This means <code>debug</code> and <code>trace</code> messages are hidden from the console and output log unless a more verbose level is explicitly set.</p>"},{"location":"TESTS/LOGGING/#the-ltf-logs-utility","title":"The <code>ltf logs</code> Utility","text":"<p>LTF includes a command-line utility for quickly parsing and viewing information from log files.</p>"},{"location":"TESTS/LOGGING/#ltf-logs-info","title":"<code>ltf logs info</code>","text":"<p>This command parses a Raw Log file and presents a concise summary of the test run, including test counts, pass/fail rates, and duration.</p> <p>Usage:</p> <pre><code>ltf logs info &lt;path_to_raw_log.json | latest&gt;\n</code></pre> <p>Examples:</p> <pre><code># Show info from the most recent test run\nltf logs info latest\n\n# Show info from a specific log file\nltf logs info logs/test_run_2023-10-27-143000_raw.json\n</code></pre>"},{"location":"TESTS/TAG_SYSTEM/","title":"Tag System","text":"<p>The LTF tag system is a powerful feature for categorizing, organizing, and selectively running your tests. By assigning tags to your test cases, you can easily create and execute different test suites on the fly.</p> <p>This is especially useful for: *   Creating subsets of tests, like <code>smoke</code>, <code>regression</code>, or <code>performance</code>. *   Running all tests related to a specific feature, like <code>api</code>, <code>ui</code>, or <code>login</code>. *   Separating tests that require specific hardware or environments.</p>"},{"location":"TESTS/TAG_SYSTEM/#defining-tags-in-your-tests","title":"Defining Tags in Your Tests","text":"<p>You can assign tags to any test by assigning a table of strings to the optional parameter <code>tags</code>:</p> <pre><code>local ltf = require(\"ltf\")\n\n-- This test is tagged as both \"api\" and \"smoke\"\nltf.test({\n    name = \"Verify user login endpoint\",\n    tags = { \"api\", \"smoke\" },\n    body = function()\n        -- ... Test logic ...\n    end,\n})\n\n-- This test is only tagged as \"api\"\nltf.test({\n    name = \"Check user profile data\",\n    tags = { \"api\" },\n    body = function()\n        -- ... Test logic ...\n    end,\n})\n\n-- This test has no tags\nltf.test({\n    name = \"Simple utility function check\",\n    body = function()\n        -- ... Test logic ...\n    end,\n})\n</code></pre> <p>Tags are passed as a simple array-like table of strings: <code>{ \"tag1\", \"tag2\", ... }</code>.</p>"},{"location":"TESTS/TAG_SYSTEM/#running-tests-by-tag","title":"Running Tests by Tag","text":"<p>To run only the tests that match specific tags, use the <code>--tags</code> or <code>-t</code> command-line flag. You can provide a single tag or a comma-separated list of tags.</p> Flag Description <code>--tags &lt;tags&gt;</code> The full command-line flag. <code>-t &lt;tags&gt;</code> The short-form alias. <p>Example Usage:</p> <pre><code># Run all tests with the \"api\" tag\nltf test --tags api\n\n# Run all tests with the \"smoke\" tag (short form)\nltf test -t smoke\n\n# Run tests that have EITHER the \"api\" OR \"smoke\" tag\nltf test -t api,smoke\n</code></pre>"},{"location":"TESTS/TAG_SYSTEM/#understanding-the-filtering-logic","title":"Understanding the Filtering Logic","text":"<p>Tag filtering is inclusive (using OR logic).</p> <p>This means that a test will be selected to run if it has at least one of the tags you provide on the command line.</p> <p>Let's use our code example from above to see how this works in practice.</p>"},{"location":"TESTS/TAG_SYSTEM/#scenario-1-running-with-a-specific-feature-tag","title":"Scenario 1: Running with a specific feature tag","text":"<pre><code>ltf test -t api\n</code></pre> <ul> <li>Result: This will execute both \"Verify user login endpoint\" and \"Check user profile data\" because both tests include the <code>api</code> tag.</li> </ul>"},{"location":"TESTS/TAG_SYSTEM/#scenario-2-running-with-a-suite-tag","title":"Scenario 2: Running with a suite tag","text":"<pre><code>ltf test -t smoke\n</code></pre> <ul> <li>Result: This will only execute \"Verify user login endpoint\" because it's the only test with the <code>smoke</code> tag.</li> </ul>"},{"location":"TESTS/TAG_SYSTEM/#scenario-3-running-with-multiple-tags","title":"Scenario 3: Running with multiple tags","text":"<pre><code>ltf test -t api,smoke\n</code></pre> <ul> <li>Result: This will execute both \"Verify user login endpoint\" and \"Check user profile data\".<ul> <li>The first test runs because it has both <code>api</code> and <code>smoke</code> tags.</li> <li>The second test runs because it has the <code>api</code> tag.</li> </ul> </li> <li>The un-tagged test, \"Simple utility function check,\" will not run in any of these scenarios. It will only run if you execute <code>ltf test</code> without any tag filters.</li> </ul>"},{"location":"TESTS/TEST_DESCRIPTION/","title":"LTF Test Description","text":"<p>Every LTF Test can also have an optional description field if you would like to give more context to the test besides the test name.</p> <pre><code>local ltf = require(\"ltf\")\n\n-- This test has a single-line description\nltf.test({\n    name = \"Example Test 1\",\n    description = \"This is just an example test\",\n    body = function()\n        -- Some very important test logic goes here\n    end,\n})\n\n-- This test has a multiline description\nltf.test({\n    name = \"Example Test 2\",\n    description = [[\n    This is an example of multiline\n    test description.\n    You can describe everything here.\n    ]],\n    body = function()\n        -- Some very important test logic goes here\n    end,\n})\n\n-- This test has no description\nltf.test({\n    name = \"Example Test 3\",\n    body = function()\n        -- Some very important test logic goes here\n    end,\n})\n</code></pre>"},{"location":"TESTS/TEST_OVERRIDING/","title":"Test Overriding Behavior","text":"<p>The Test Automation Framework (LTF) uses a test's name as its unique identifier. If LTF discovers multiple tests with the exact same name during its discovery phase, it will override the earlier definitions and only execute the version of the test that was registered last.</p> <p>This behavior, while applicable in all project types, is most powerful and intentionally useful in Multi-Target Projects for creating target-specific implementations of common tests.</p>"},{"location":"TESTS/TEST_OVERRIDING/#test-discovery-and-execution-order","title":"Test Discovery and Execution Order","text":"<p>To understand overriding, it's essential to know the order in which LTF discovers and loads files. LTF scans and executes Lua files recursively, iterating through directories and files alphabetically at each level.</p>"},{"location":"TESTS/TEST_OVERRIDING/#single-target-project-order","title":"Single-Target Project Order","text":"<ol> <li><code>lib/</code> directory: All <code>.lua</code> files are executed alphabetically.</li> <li><code>tests/</code> directory: All <code>.lua</code> files are executed alphabetically.</li> </ol>"},{"location":"TESTS/TEST_OVERRIDING/#multi-target-project-order-when-running-for-target_name","title":"Multi-Target Project Order (when running for <code>&lt;target_name&gt;</code>)","text":"<ol> <li><code>lib/</code> directory: All <code>.lua</code> files are executed alphabetically.</li> <li><code>tests/common/</code> directory: All <code>.lua</code> files are executed alphabetically.</li> <li><code>tests/&lt;target_name&gt;/</code> directory: All <code>.lua</code> files are executed alphabetically.</li> </ol> <p>The test runner collects all <code>ltf.test()</code> definitions as it executes these files. If a test name is re-registered, the new test body and tags replace the old ones.</p>"},{"location":"TESTS/TEST_OVERRIDING/#use-case-overriding-common-tests-in-a-multi-target-project","title":"Use Case: Overriding Common Tests in a Multi-Target Project","text":"<p>The primary use case for this behavior is to provide a default test implementation in the <code>tests/common/</code> directory that can be selectively overridden by a specific target.</p> <p>Imagine you have a common test to check the system's kernel version, but one of your targets is a unique device that requires a special method to retrieve this information.</p>"},{"location":"TESTS/TEST_OVERRIDING/#1-define-the-common-test","title":"1. Define the Common Test","text":"<p>First, you create the generic test in the <code>tests/common/</code> directory.</p> <p>File: <code>tests/common/system_checks.lua</code></p> <pre><code>local ltf = require(\"ltf\")\n\nltf.test({\n    name = \"Verify Kernel Version\",\n    tags = { \"system\", \"smoke\" },\n    body = function()\n        ltf.log_info(\"Running the standard kernel version check...\")\n\n        -- Standard command to get kernel version\n        local result = ltf.proc.run({ exe = \"uname\", args = {\"-r\"} })\n\n        if result.exitcode ~= 0 then\n            ltf.log_critical(\"Failed to run 'uname -r'\")\n        end\n\n        local version = result.stdout\n        ltf.log_info(\"Detected kernel version:\", version)\n\n        -- Assert that the version starts with \"5.\"\n        if not version:match(\"^5.\") then\n            ltf.log_error(\"Expected a 5.x kernel, but got \" .. version)\n        end\n    end,\n})\n</code></pre> <p>This test will run for every target by default.</p>"},{"location":"TESTS/TEST_OVERRIDING/#2-override-the-test-for-a-specific-target","title":"2. Override the Test for a Specific Target","text":"<p>Now, for your special target named <code>special_device</code>, you need a different implementation. You create a new test file in that target's directory and use the exact same test name.</p> <p>File: <code>tests/special_device/custom_checks.lua</code></p> <pre><code>local ltf = require(\"ltf\")\n\n-- This test will OVERRIDE the one defined in tests/common/\nltf.test({\n    name = \"Verify Kernel Version\",\n    tags = { \"system\", \"special\" },\n    body = function()\n        ltf.log_info(\"Running the CUSTOM kernel version check for special_device...\")\n\n        -- A custom command or method for this specific device\n        local result = ltf.proc.run({ exe = \"get_special_kernel_version.sh\" })\n\n        if result.exitcode ~= 0 then\n            ltf.log_critical(\"Failed to run custom kernel script\")\n        end\n\n        local version = result.stdout\n        ltf.log_info(\"Detected special kernel version:\", version)\n\n        -- This device uses a 4.x kernel\n        if not version:match(\"^4.\") then\n            ltf.log_error(\"Expected a 4.x kernel for this device, but got \" .. version)\n        end\n    end,\n})\n</code></pre>"},{"location":"TESTS/TEST_OVERRIDING/#execution-outcome","title":"Execution Outcome","text":"<ul> <li> <p>When you run <code>ltf test normal_device</code>:</p> <ul> <li>LTF loads <code>tests/common/system_checks.lua</code>.</li> <li>The test \"Verify Kernel Version\" is registered.</li> <li>LTF executes the common version of the test.</li> </ul> </li> <li> <p>When you run <code>ltf test special_device</code>:</p> <ul> <li>LTF first loads <code>tests/common/system_checks.lua</code>, and the common test is registered.</li> <li>Then, LTF loads <code>tests/special_device/custom_checks.lua</code>. The test \"Verify Kernel Version\" is discovered again.</li> <li>The framework overwrites the previous definition with this new one (including its new tags: <code>{ \"system\", \"special\" }</code>).</li> <li>LTF executes the custom version of the test defined in the target's directory.</li> </ul> </li> </ul> <p>This powerful mechanism allows you to maintain a clean, shared test suite in <code>common</code> while handling exceptions and target-specific logic in a clear and organized way.</p>"},{"location":"TESTS/TEST_SCENARIOS/","title":"Test scenarios","text":"<p>Sometimes you need more control over a test run than what CLI flags alone can express. Scenarios let you describe a test run in a JSON file: variables, tags, log settings, and (optionally) a preferred test execution order.</p>"},{"location":"TESTS/TEST_SCENARIOS/#scenario-file","title":"Scenario file","text":"<p>Example scenario:</p> <p>File: <code>scenarios/scenario.json</code></p> <pre><code>{\n  \"cmd\": {\n    \"vars\": {\n      \"var1\": \"somevar1\",\n      \"var2\": \"somevar2\"\n    },\n    \"tags\": [\"tag1\", \"tag2\", \"tag3\"],\n    \"log_level\": \"info\"\n  },\n  \"order\": [\"First test\", \"Second test\"]\n}\n</code></pre> <p>You can place scenario files anywhere, but the recommended convention is a <code>scenarios/</code> folder.</p>"},{"location":"TESTS/TEST_SCENARIOS/#running-a-scenario","title":"Running a scenario","text":"<pre><code>ltf test -s scenarios/scenario.json\n</code></pre>"},{"location":"TESTS/TEST_SCENARIOS/#cli-overrides-scenario-values","title":"CLI overrides scenario values","text":"<p>Anything under <code>cmd</code> can still be overridden via CLI flags. CLI always wins.</p> <pre><code>ltf test -s scenarios/scenario.json -v var1:new_var1\n</code></pre> <p>In this example, <code>var1</code> will be <code>new_var1</code> even though the scenario sets it to <code>somevar1</code>.</p>"},{"location":"TESTS/TEST_SCENARIOS/#how-ordering-works","title":"How ordering works","text":"<p>The <code>order</code> field does not \u201cforce-run\u201d tests by itself.</p> <ol> <li>LTF first collects/registers tests that match the requested <code>cmd.tags</code> (and <code>cmd.target</code> if the project is multi-target).</li> <li>Then it tries to reorder that selected set according to <code>order</code>.</li> </ol> <p>If a test name in <code>order</code> is not part of the selected set (wrong tags/target or not registered), it won\u2019t run just because it\u2019s listed.</p>"},{"location":"TESTS/TEST_SCENARIOS/#properties","title":"Properties","text":""},{"location":"TESTS/TEST_SCENARIOS/#cmdtarget","title":"<code>cmd.target</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Meaning: Select the test target (only relevant for multi-target projects).</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#cmdtags","title":"<code>cmd.tags</code>","text":"<ul> <li>Type: <code>string[]</code></li> <li>Meaning: Tags to filter which tests are included in the run.</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#cmdvars","title":"<code>cmd.vars</code>","text":"<ul> <li>Type: <code>object</code> (<code>{ \"name\": \"value\" }</code>)</li> <li>Meaning: Variables for the run (same idea as <code>-v/--vars</code>).</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#cmdlog_level","title":"<code>cmd.log_level</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Meaning: Log verbosity.</li> <li>Allowed values: <code>\"critical\"</code>, <code>\"error\"</code>, <code>\"warning\"</code>, <code>\"info\"</code>, <code>\"debug\"</code>, <code>\"trace\"</code>.</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#cmdno_logs","title":"<code>cmd.no_logs</code>","text":"<ul> <li>Type: <code>boolean</code></li> <li>Meaning: Disable log output for the run.</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#cmdheadless","title":"<code>cmd.headless</code>","text":"<ul> <li>Type: <code>boolean</code></li> <li>Meaning: Run without the TUI (\u201cheadless\u201d mode).</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#cmdltf_lib_path","title":"<code>cmd.ltf_lib_path</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Meaning: Use a custom path to the LTF library.</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#order","title":"<code>order</code>","text":"<ul> <li>Type: <code>string[]</code></li> <li>Meaning: Desired execution order by test name.</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#composing-and-overriding-scenarios","title":"Composing and overriding scenarios","text":"<p>Scenarios can include another scenario and then modify parts of it. This is useful for \u201cbase scenario + small changes\u201d.</p> <pre><code>{\n  \"include\": \"path_to_other_scenario\",\n  \"cmd\": {\n    \"vars:append\": {\n      \"var3\": \"somevar3\"\n    },\n    \"vars:remove\": [\"var2\"],\n    \"tags\": [\"someothertag1\", \"someothertag2\"]\n  },\n  \"order:append\": [\"Third test\"],\n  \"order:remove\": [\"Second test\"]\n}\n</code></pre>"},{"location":"TESTS/TEST_SCENARIOS/#override-rules","title":"Override rules","text":"<ul> <li>Use <code>:append</code> to add items to \u201carray-like\u201d fields.</li> <li>Use <code>:remove</code> to remove items.</li> <li>Or just redeclare the field entirely (like <code>cmd.tags</code> above).</li> </ul> <p>Common patterns:</p> <ul> <li>Start with a base scenario that sets target + common vars.</li> <li>Create smaller scenarios that include it and tweak vars/tags/order.</li> </ul>"},{"location":"TESTS/TEST_SCENARIOS/#examples","title":"Examples","text":"<p>See project example.</p>"},{"location":"TESTS/TEST_SECRETS/","title":"Test secrets","text":"<p>LTF supports secrets: named sensitive values (tokens, passwords, API keys) that are loaded from a local <code>.secrets</code> file and accessed in tests at runtime.</p>"},{"location":"TESTS/TEST_SECRETS/#registering-secrets","title":"Registering secrets","text":"<p>Register secrets at Lua top level using <code>ltf.register_secrets()</code>. Like variables, you can call this in any file, but it\u2019s usually best to keep it organized (for example in <code>lib/secrets.lua</code>).</p> <pre><code>local ltf = require(\"ltf\")\n\nltf.register_secrets({\n  \"secret1\",\n  \"secret2\",\n})\n</code></pre>"},{"location":"TESTS/TEST_SECRETS/#using-secrets-in-a-test","title":"Using secrets in a test","text":"<p>Use <code>ltf.get_secret()</code> to retrieve a secret by name.</p> <pre><code>local ltf = require(\"ltf\")\n\nltf.test({\n  name = \"Example test\",\n  body = function()\n    local secret1 = ltf.get_secret(\"secret1\")\n    local secret2 = ltf.get_secret(\"secret2\")\n\n    ltf.log_info(\"Secret value 1 is: \" .. secret1)\n    ltf.log_info(\"Secret value 2 is: \" .. secret2)\n  end,\n})\n</code></pre>"},{"location":"TESTS/TEST_SECRETS/#providing-secret-values","title":"Providing secret values","text":"<p>Secret values are stored in a file named <code>.secrets</code> in the project root.</p>"},{"location":"TESTS/TEST_SECRETS/#single-line-secrets","title":"Single-line secrets","text":"<pre><code>secret1=somesecretvalue\n</code></pre>"},{"location":"TESTS/TEST_SECRETS/#multiline-secrets","title":"Multiline secrets","text":"<p>Use triple quotes to define multiline values:</p> <pre><code>secret2=\"\"\"\nsome\nother\nmultiline\nsecret\nvalue\n\"\"\"\n</code></pre> <p>Full example:</p> <pre><code>secret1=somesecretvalue\nsecret2=\"\"\"\nsome\nother\nmultiline\nsecret\nvalue\n\"\"\"\n</code></pre>"},{"location":"TESTS/TEST_SECRETS/#running-tests","title":"Running tests","text":"<p>Once the secrets are registered and <code>.secrets</code> is present:</p> <pre><code>ltf test\n</code></pre>"},{"location":"TESTS/TEST_SECRETS/#git-safety","title":"Git safety","text":"<p>The <code>.secrets</code> file must not be committed. LTF adds it to <code>.gitignore</code> by default when you create a project with:</p> <pre><code>ltf init\n</code></pre>"},{"location":"TESTS/TEST_SECRETS/#validation-rules","title":"Validation rules","text":"<p>LTF validates secrets before any tests run:</p> <ul> <li>Every name registered via <code>ltf.register_secrets()</code> must exist in <code>.secrets</code></li> <li>Every registered secret must have a value (including multiline values)</li> </ul> <p>If any registered secret is missing (or has no value), LTF exits with an error and does not start tests.</p>"},{"location":"TESTS/TEST_SECRETS/#example","title":"Example","text":"<p>See project example.</p>"},{"location":"TESTS/TEST_TEARDOWN/","title":"Test Teardown with <code>ltf.defer</code>","text":"<p>In testing, it's crucial to clean up resources\u2014like closing files, shutting down network connections, or deleting temporary data\u2014at the end of a test. The <code>ltf.defer</code> function provides a robust and reliable mechanism to ensure this cleanup happens consistently.</p> <p><code>ltf.defer</code> registers a function to be executed immediately after the current test case finishes, regardless of its outcome.</p>"},{"location":"TESTS/TEST_TEARDOWN/#guaranteed-cleanup","title":"Guaranteed Cleanup","text":"<p>The primary purpose of <code>ltf.defer</code> is to guarantee that cleanup code runs, even if the test fails unexpectedly.</p> <pre><code>local ltf = require(\"ltf\")\n\nltf.test({\n    name = \"Resource cleanup example\",\n    body = function()\n        ltf.log_info(\"Opening a resource...\")\n        local resource = open_critical_resource()\n        assert(resource, \"Test cannot continue if resource failed to open\")\n\n        -- This defer is now registered.\n        ltf.defer(function()\n            ltf.log_info(\"Closing the critical resource.\")\n            close_critical_resource(resource)\n        end)\n\n        ltf.log_info(\"Performing actions with the resource...\")\n        -- ... more test logic ...\n\n        -- Let's imagine the test fails here\n        -- ltf.log_critical(\"Something went wrong!\")\n    end,\n})\n</code></pre> <p>Important: * It does not matter if the test passes or fails.</p> <p>Once a defer function is registered, it will be invoked.    However, if the test exits before the <code>ltf.defer</code> line is reached (like in our <code>assert</code> example), the defer function will not have been registered and will not run.</p> <ul> <li>Defer cannot fail test in any way.</li> </ul> <p>Test status is determined before defer queue is executed.    If defer fails LTF will let you know about it.</p>"},{"location":"TESTS/TEST_TEARDOWN/#execution-order-last-in-first-out-lifo","title":"Execution Order: Last-In, First-Out (LIFO)","text":"<p>You can register multiple <code>defer</code> functions within a single test. They are executed in a \"Last-In, First-Out\" (LIFO) order, meaning the last defer registered is the first one to run upon completion.</p> <pre><code>ltf.test({\n    name = \"LIFO defer demonstration\",\n    body = function()\n        -- First defer registered\n        ltf.defer(function()\n            print(\"This defer runs second.\")\n        end)\n\n        -- Second defer registered\n        ltf.defer(function()\n            print(\"This defer runs first!\")\n        end)\n\n        print(\"Test logic is executing...\")\n    end,\n})\n</code></pre> <p>Test Output:</p> <pre><code>Test logic is executing...\nThis defer runs first!\nThis defer runs second.\n</code></pre> <p>This LIFO behavior is useful for handling dependent resources, ensuring things are cleaned up in the reverse order of their creation.</p>"},{"location":"TESTS/TEST_TEARDOWN/#conditional-cleanup-with-status","title":"Conditional Cleanup with <code>status</code>","text":"<p>A deferred function can optionally accept a single argument, which LTF will provide. This argument is a string containing the test's final status: either <code>\"passed\"</code> or <code>\"failed\"</code>.</p> <p>This allows you to perform conditional logic during teardown, such as saving extra debug information only when a test fails.</p> <pre><code>ltf.test({\n    name = \"Conditional defer example\",\n    body = function()\n        ltf.defer(function(status)\n            if status == \"failed\" then\n                print(\"Oh no! The test failed. Saving diagnostic data...\")\n                -- save_debug_logs()\n            elseif status == \"passed\" then\n                print(\"Hooray! The test passed.\")\n            end\n        end)\n\n        -- Test logic that might pass or fail\n        local success = perform_complex_operation()\n        if not success then\n            ltf.log_error(\"The complex operation failed!\")\n        end\n    end,\n})\n</code></pre>"},{"location":"TESTS/TEST_TEARDOWN/#simplified-syntax-passing-arguments-directly","title":"Simplified Syntax: Passing Arguments Directly","text":"<p>For simple cleanup calls, you can use an alternative syntax that avoids writing an anonymous function. Pass the function name as the first argument to <code>ltf.defer</code>, and any subsequent arguments will be passed directly to that function when it's executed.</p> <pre><code>local ltf = require(\"ltf\")\n\nltf.test({\n    name = \"Simplified defer syntax\",\n    body = function()\n        local port = open_some_port()\n        assert(port, \"Port could not be opened\")\n\n        -- Default defer style:\n        ltf.defer(function()\n            print(\"Closing port...\")\n        end)\n\n        -- Simplified defer style:\n        -- Passes the 'port' variable to the 'close_some_port' function on execution.\n        ltf.defer(close_some_port, port)\n\n        -- This is also valid and is equivalent to the first defer.\n        ltf.defer(print, \"Closing port...\")\n    end,\n})\n</code></pre> <p>Both styles are fully supported. The simplified syntax can make your code more concise, while the standard function block offers more flexibility for complex logic. Choose the style that you find more readable and elegant for your use case.</p>"},{"location":"TESTS/TEST_VARIABLES/","title":"Test variables","text":"<p>LTF supports test variables: named values you register in Lua and optionally override from the CLI. Tests read them at runtime with <code>ltf.get_var()</code>.</p>"},{"location":"TESTS/TEST_VARIABLES/#registering-variables","title":"Registering variables","text":"<p>Call <code>ltf.register_vars()</code> at Lua top level (not inside a test body). You can place it anywhere, but it\u2019s usually best to keep variables in one file (for example <code>lib/variables.lua</code>).</p> <pre><code>local ltf = require(\"ltf\")\n\nltf.register_vars({\n  project = \"my-project\",\n})\n</code></pre> <p>You can call <code>ltf.register_vars</code> as much as you need and do it across different files as long as the variables you are registering are unique.</p>"},{"location":"TESTS/TEST_VARIABLES/#using-variables-in-a-test","title":"Using variables in a test","text":"<pre><code>local ltf = require(\"ltf\")\n\nltf.test({\n  name = \"Example Test\",\n  body = function()\n    local project = ltf.get_var(\"project\")\n    ltf.log_info(\"Project is: \" .. project)\n  end,\n})\n</code></pre>"},{"location":"TESTS/TEST_VARIABLES/#variable-forms","title":"Variable forms","text":"<p>LTF variables can be registered in one of these five forms:</p>"},{"location":"TESTS/TEST_VARIABLES/#1-constant","title":"1) Constant","text":"<p>Fixed value. Cannot be overridden.</p> <pre><code>ltf.register_vars({\n  device_type = \"stm32\",\n})\n</code></pre> <p>Use when the test suite is tied to a specific value.</p>"},{"location":"TESTS/TEST_VARIABLES/#2-required","title":"2) Required","text":"<p>Must be provided (typically via CLI). No default.</p> <pre><code>ltf.register_vars({\n  serial_port = {},\n})\n</code></pre> <p>Use when the value depends on the environment (like <code>/dev/ttyUSB0</code>).</p>"},{"location":"TESTS/TEST_VARIABLES/#3-default","title":"3) Default","text":"<p>Optional. Uses <code>default</code> unless overridden.</p> <pre><code>ltf.register_vars({\n  baudrate = { default = \"115200\" },\n})\n</code></pre> <p>Use when most runs share a common value, but you occasionally change it.</p>"},{"location":"TESTS/TEST_VARIABLES/#4-enum","title":"4) Enum","text":"<p>Restricted set. Value must be one of <code>values</code>.</p> <pre><code>ltf.register_vars({\n  log_level = {\n    values = { \"critical\", \"debug\", \"info\", \"warning\", \"error\" },\n  },\n})\n</code></pre> <p>Use when you only want to allow known modes.</p>"},{"location":"TESTS/TEST_VARIABLES/#5-enum-with-default","title":"5) Enum with default","text":"<p>Restricted set + default. Default must be in <code>values</code>.</p> <pre><code>ltf.register_vars({\n  env = {\n    default = \"dev\",\n    values = { \"dev\", \"staging\", \"prod\" },\n  },\n})\n</code></pre> <p>Use when there\u2019s a standard choice, but you still want strict allowed values.</p>"},{"location":"TESTS/TEST_VARIABLES/#setting-variables","title":"Setting variables","text":"<p>Pass variables as <code>name=value</code> pairs, separated by commas:</p> <pre><code>ltf test --vars serial_port=/dev/ttyUSB0,env=staging,log_level=debug\n</code></pre> <p>Shorthand:</p> <pre><code>ltf test -v serial_port=/dev/ttyUSB0,env=staging\n</code></pre> <p>You can also set variables by multiple <code>-v/--vars</code>:</p> <pre><code>ltf test -v serial_port=/dev/ttyUSB0 -v env=staging\n</code></pre> <p>If you need to set variable which contains comma(s), just wrap it in quotes:</p> <pre><code>ltf test -v enumeration=\"one,two,three\",serial_port=/dev/ttyUSB0\n</code></pre> <p>Alternatively, variables can also be set via Test Scenarios.</p>"},{"location":"TESTS/TEST_VARIABLES/#validation-rules","title":"Validation rules","text":"<p>LTF validates variables before any tests run:</p> <ul> <li>Constant variables cannot be overridden from the CLI.</li> <li>For Enum and Enum with default:</li> <li>CLI values must be listed in <code>values</code></li> <li><code>default</code> (if present) must also be listed in <code>values</code></li> <li>If specified variable was not registered LTF will print warning message but continue executing tests.</li> </ul> <p>If validation fails, LTF exits with an error before executing tests.</p>"},{"location":"TESTS/TEST_VARIABLES/#example","title":"Example","text":"<p>See project example.</p>"}]}