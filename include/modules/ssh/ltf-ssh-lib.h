#ifndef MODULE_SSH2_LIB_H
#define MODULE_SSH2_LIB_H

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
#include <libssh2.h>
#define SSH_LIBMOD_MT "ltf-ssh-libmod"
#define SSH_LIB_MT "ltf-ssh"

static const char *unknown_err_output = "UNKNOWN";
static const struct {
    int code;
    const char *name;
} ssh_error_map[] = {
    {LIBSSH2_ERROR_NONE, "NONE"},
    {LIBSSH2_ERROR_SOCKET_NONE, "SOCKET_NONE"},
    {LIBSSH2_ERROR_BANNER_RECV, "BANNER_RECV"},
    {LIBSSH2_ERROR_BANNER_SEND, "BANNER_SEND"},
    {LIBSSH2_ERROR_INVALID_MAC, "INVALID_MAC"},
    {LIBSSH2_ERROR_KEX_FAILURE, "KEX_FAILURE"},
    {LIBSSH2_ERROR_ALLOC, "ALLOC"},
    {LIBSSH2_ERROR_SOCKET_SEND, "SOCKET_SEND"},
    {LIBSSH2_ERROR_KEY_EXCHANGE_FAILURE, "KEY_EXCHANGE_FAILURE"},
    {LIBSSH2_ERROR_TIMEOUT, "TIMEOUT"},
    {LIBSSH2_ERROR_HOSTKEY_INIT, "HOSTKEY_INIT"},
    {LIBSSH2_ERROR_HOSTKEY_SIGN, "HOSTKEY_SIGN"},
    {LIBSSH2_ERROR_DECRYPT, "DECRYPT"},
    {LIBSSH2_ERROR_SOCKET_DISCONNECT, "SOCKET_DISCONNECT"},
    {LIBSSH2_ERROR_PROTO, "PROTO"},
    {LIBSSH2_ERROR_PASSWORD_EXPIRED, "PASSWORD_EXPIRED"},
    {LIBSSH2_ERROR_FILE, "FILE"},
    {LIBSSH2_ERROR_METHOD_NONE, "METHOD_NONE"},
    {LIBSSH2_ERROR_AUTHENTICATION_FAILED, "AUTHENTICATION_FAILED"},
    /* PUBLICKEY_UNRECOGNIZED == AUTHENTICATION_FAILED (same code) */
    {LIBSSH2_ERROR_PUBLICKEY_UNVERIFIED, "PUBLICKEY_UNVERIFIED"},
    {LIBSSH2_ERROR_CHANNEL_OUTOFORDER, "CHANNEL_OUTOFORDER"},
    {LIBSSH2_ERROR_CHANNEL_FAILURE, "CHANNEL_FAILURE"},
    {LIBSSH2_ERROR_CHANNEL_REQUEST_DENIED, "CHANNEL_REQUEST_DENIED"},
    {LIBSSH2_ERROR_CHANNEL_UNKNOWN, "CHANNEL_UNKNOWN"},
    {LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED, "CHANNEL_WINDOW_EXCEEDED"},
    {LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED, "CHANNEL_PACKET_EXCEEDED"},
    {LIBSSH2_ERROR_CHANNEL_CLOSED, "CHANNEL_CLOSED"},
    {LIBSSH2_ERROR_CHANNEL_EOF_SENT, "CHANNEL_EOF_SENT"},
    {LIBSSH2_ERROR_SCP_PROTOCOL, "SCP_PROTOCOL"},
    {LIBSSH2_ERROR_ZLIB, "ZLIB"},
    {LIBSSH2_ERROR_SOCKET_TIMEOUT, "SOCKET_TIMEOUT"},
    {LIBSSH2_ERROR_SFTP_PROTOCOL, "SFTP_PROTOCOL"},
    {LIBSSH2_ERROR_REQUEST_DENIED, "REQUEST_DENIED"},
    {LIBSSH2_ERROR_METHOD_NOT_SUPPORTED, "METHOD_NOT_SUPPORTED"},
    {LIBSSH2_ERROR_INVAL, "INVAL"},
    {LIBSSH2_ERROR_INVALID_POLL_TYPE, "INVALID_POLL_TYPE"},
    {LIBSSH2_ERROR_PUBLICKEY_PROTOCOL, "PUBLICKEY_PROTOCOL"},
    {LIBSSH2_ERROR_EAGAIN, "EAGAIN"},
    {LIBSSH2_ERROR_BUFFER_TOO_SMALL, "BUFFER_TOO_SMALL"},
    {LIBSSH2_ERROR_BAD_USE, "BAD_USE"},
    {LIBSSH2_ERROR_COMPRESS, "COMPRESS"},
    {LIBSSH2_ERROR_OUT_OF_BOUNDARY, "OUT_OF_BOUNDARY"},
    {LIBSSH2_ERROR_AGENT_PROTOCOL, "AGENT_PROTOCOL"},
    {LIBSSH2_ERROR_SOCKET_RECV, "SOCKET_RECV"},
    {LIBSSH2_ERROR_ENCRYPT, "ENCRYPT"},
    {LIBSSH2_ERROR_BAD_SOCKET, "BAD_SOCKET"},
    {LIBSSH2_ERROR_KNOWN_HOSTS, "KNOWN_HOSTS"},
    {LIBSSH2_ERROR_CHANNEL_WINDOW_FULL, "CHANNEL_WINDOW_FULL"},
    {LIBSSH2_ERROR_KEYFILE_AUTH_FAILED, "KEYFILE_AUTH_FAILED"},
    {LIBSSH2_ERROR_RANDGEN, "RANDGEN"},
    {LIBSSH2_ERROR_MISSING_USERAUTH_BANNER, "MISSING_USERAUTH_BANNER"},
    {LIBSSH2_ERROR_ALGO_UNSUPPORTED, "ALGO_UNSUPPORTED"},
    {LIBSSH2_ERROR_MAC_FAILURE, "MAC_FAILURE"},
    {LIBSSH2_ERROR_HASH_INIT, "HASH_INIT"},
    {LIBSSH2_ERROR_HASH_CALC, "HASH_CALC"},
    {0, NULL}};

// ts:init() -> bool or err msg
int l_module_ssh_lib_init(lua_State *L);
// ts:exit() -> bool 
int l_module_ssh_lib_exit(lua_State *L);

int l_module_ssh_lib_free(lua_State *L); // Do not use
int l_module_ssh_lib_hostkey_hash(lua_State *L); // Do not use

int l_module_ssh_banner_set(lua_State *L); // Do not use
int l_module_ssh_base64_decode(lua_State *L); // Do not use

int l_module_ssh_poll(lua_State *L); // Do not use
int l_module_ssh_poll_chanell_read(lua_State *L); // Do not use

int l_module_ssh_trace(lua_State *L); // Do not use
int l_module_ssh_trace_sethandler(lua_State *L); // Do not use


const char *ssh_err_to_str(int code);

int l_module_ssh_socket_connect(lua_State *L);

int l_module_ssh_register_module(lua_State *L);


#endif // MODULE_SSH2_LIB_H
